module.exports = function (RED) {
    "use strict";
    const reconnect = RED.settings.mysqlReconnectTime || 20000;
    const {Sequelize, DataTypes, Deferrable, Model} = require('sequelize');

    function MydbNode(n) {
        RED.nodes.createNode(this, n);
        this.dialect = n.dialect;
        this.host = n.host;
        this.port = n.port;
        this.tz = n.tz || "+08:00";
        this.charset = (n.charset || "utf8mb4").toUpperCase();
        this.options = n.options ? JSON.parse(n.options) : {};
        this.model = n.model ? JSON.parse(n.model) : {};

        this.connected = false;
        this.connecting = false;

        this.dbname = n.db;
        this.setMaxListeners(0);
        var node = this;

        function checkVer() {
            node.pool.authenticate().then(() => {

                console.log('authenticate_checkVer');
            }, (err) => {
                node.error(err);
                node.status({fill: "red", shape: "ring", text: RED._("mydb.status.badping")});
                doConnect();
            });
        }

        function doConnect() {
            node.connecting = true;
            node.emit("state", "connecting");
            if (!node.pool) {
                node.pool = new Sequelize(Object.assign(
                {},node.options,
                {
                    dialect: node.dialect,
                    host: node.host,
                    port: node.port,
                    username: node.credentials.user,
                    password: node.credentials.password,
                    database: node.dbname,
                    timezone: node.tz,
                    charset: node.charset
                }));
            }

            node.pool.authenticate().then(() => {
                node.connected = true;
                node.emit("state", "connected");
                if (!node.check) {
                    node.check = setInterval(checkVer, 290000);
                }
            }, (err) => {
                node.emit("state", err.code);
                node.error(err);
                node.tick = setTimeout(doConnect, reconnect);
            });
        }

        this.connect = function () {
            if (!this.connected && !this.connecting) {
                doConnect();
            }
        }

        this.on('close', function (done) {
            if (this.tick) {
                clearTimeout(this.tick);
            }
            if (this.check) {
                clearInterval(this.check);
            }
            node.connected = false;
            node.emit("state", " ");
            done();
        });
    }

    RED.nodes.registerType("MydbDatabase", MydbNode, {
        credentials: {
            user: {type: "text"},
            password: {type: "password"}
        }
    });


    function MydbNodeIn(n) {
        RED.nodes.createNode(this, n);
        this.mydb = n.mydb;
        this.mydbConfig = RED.nodes.getNode(this.mydb);
        this.status({});

        if (this.mydbConfig) {
            this.mydbConfig.connect();
            var node = this;
            var busy = false;
            var status = {};
            node.mydbConfig.on("state", function (info) {
                if (info === "connecting") {
                    node.status({fill: "grey", shape: "ring", text: RED._("mydb.status.connecting")});
                } else if (info === "connected") {
                    node.status({fill: "green", shape: "dot", text: RED._("mydb.status.connected")});
                } else {
                    node.status({fill: "red", shape: "ring", text: info});
                }
            });

            node.on("input", function (msg, send, done) {
                send = send || function () {
                    node.send.apply(node, arguments)
                };
                if (node.mydbConfig.connected) {
                    msg.mydb = node.mydbConfig.pool;
                    msg.model = Object.assign({}, msg.model);
                    const modelConfig = node.mydbConfig.model;
                    const format = (data) => {
                        if (Object.prototype.toString.call(data) === '[object Object]') {
                            const output = {};
                            Object.keys(data).forEach((key) => {
                                const value = data[key];
                                output[key] = format(value);
                            });
                            return output;
                        }
                        if (Array.isArray(data)) {
                            return data.map((value) => {
                                return format[value];
                            });
                        }
                        if (typeof data === 'string' && /^(DataTypes|Sequelize|Deferrable|Model)\./.test(data)) {
                            const func = new Function('DataTypes', 'Sequelize', 'Deferrable', 'Model', `return ${data};`);
                            return func(DataTypes, Sequelize, Deferrable, Model);
                        }
                        return data;
                    };
                    // 定义model
                    Object.keys(modelConfig).forEach((key) => {
                        const value = modelConfig[key];
                        if (!msg.model[key]) {
                            msg.model[key] = msg.mydb.define(value.name, format(value.model), Object.assign({}, value.options));
                        }
                    });
                    // 处理 Association
                    Object.values(modelConfig).forEach((config) => {
                        if (config.association) {
                            const func = new Function('model', 'DataTypes', 'Sequelize', 'Deferrable', 'Model', config.association);
                            func(msg.model, DataTypes, Sequelize, Deferrable, Model);
                        }
                    });
                    send(msg);
                    status = {fill: "green", shape: "dot", text: RED._("mydb.status.ok")};
                    node.status(status);
                    done();
                } else {
                    node.error(RED._("mydb.errors.notconnected"), msg);
                    status = {fill: "red", shape: "ring", text: RED._("mydb.status.notconnected")};
                    if (done) {
                        done();
                    }
                }
                if (!busy) {
                    busy = true;
                    node.status(status);
                    node.tout = setTimeout(function () {
                        busy = false;
                        node.status(status);
                    }, 500);
                }
            });

            node.on('close', function () {
                if (node.tout) {
                    clearTimeout(node.tout);
                }
                node.mydbConfig.removeAllListeners();
                node.status({});
            });
        } else {
            this.error(RED._("mydb.errors.notconfigured"));
        }
    }

    RED.nodes.registerType("mydb", MydbNodeIn);
}
