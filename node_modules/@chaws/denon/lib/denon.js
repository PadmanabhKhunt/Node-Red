"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DenonAVR = void 0;
var events_1 = require("events");
var telnet_client_1 = __importDefault(require("telnet-client"));
/**
 * Create the controller class with the provided connection
 */
var DenonAVR = /** @class */ (function (_super) {
    __extends(DenonAVR, _super);
    function DenonAVR(config) {
        var _this = _super.call(this) || this;
        _this.config = __assign({ port: 23, sendTimeout: 1200, execTimeout: 1200, negotiationMandatory: false, shellPrompt: '', irs: '\r', ors: '\r' }, config);
        _this.connection = new telnet_client_1.default();
        return _this;
    }
    /**
     * Connect to the AVR via the defined transport
     */
    DenonAVR.prototype.connect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // setup the event emitters
                        this.connection.on('data', function (data) {
                            _this.parseData(data);
                        });
                        this.connection.on('ready', function () {
                            _this.emit('connected');
                        });
                        this.connection.on('close', function () {
                            _this.emit('disconnected');
                        });
                        return [4 /*yield*/, this.connection.connect(this.config)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    DenonAVR.prototype.disconnect = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.connection.destroy()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Send a command when we expect a single response
     *
     * @param   string    command   Command to be sent, eg MV?
     * @param   string    prefix    What the expected response will be prefixed with, eg MV for main volume
     */
    DenonAVR.prototype.send = function (cmd, prefix) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.connection.exec(cmd)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, this.parseResponse([response], prefix)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Parse a event received from the AVR not from sending a command
     *
     * @param   buffer    data
     */
    DenonAVR.prototype.parseData = function (data) {
        var value = data.toString();
        this.emit('raw', data);
        if (value.startsWith('PWON')) {
            this.emit('powerOn');
        }
        else if (value.startsWith('PWSTANDBY')) {
            this.emit('powerStandby');
        }
        else if (value.startsWith('ZMON')) {
            this.emit('mainZoneOn');
        }
        else if (value.startsWith('ZMOFF')) {
            this.emit('mainZoneOff');
        }
    };
    /**
     * Parse the response when sending a command
     *
     * @param   string        data      Data returned from the transport
     * @param   string|RegExp prefix    What the expected response will be prefixed with, eg MV for main volume
     */
    DenonAVR.prototype.parseResponse = function (data, prefix) {
        // TODO: The way this worked before there could be many callbacks
        // Check to see if that is necessary
        data.forEach(function (item) {
            if (prefix instanceof RegExp) {
                if (item.match(prefix)) {
                    return item;
                }
            }
            else {
                if (item.substring(0, prefix.length) === prefix) {
                    return item.substring(prefix.length);
                }
            }
        });
        throw new Error('Failed to parse response');
    };
    return DenonAVR;
}(events_1.EventEmitter));
exports.DenonAVR = DenonAVR;
// /**
//  * Set the power state to either true/false
//  *
//  * @param   bool      state
//  * @param   function  callback
//  */
// denon.prototype.setPowerState = function (state, callback) {
// 	var cmd = 'PWSTANDBY';
// 	if (state) {
// 		cmd = 'PWON';
// 	}
// 	this.send(cmd, 'PW', callback, 'Unable to change power state, is the AVR already set to this state?');
// }
// /**
//  * Get the current power state
//  *
//  * @param   function  callback
//  */
// denon.prototype.getPowerState = function (callback) {
// 	this.send('PW?', 'PW', callback, 'Unable to get current power state');
// }
// /**
//  * Increase the volume by 0.5dB
//  *
//  * @param   function  callback
//  */
// denon.prototype.setVolumeUp = function (callback) {
// 	this.send('MVUP', new RegExp('[A-Z]{2}[0-9]{2,3}$'), function (err, volume) {
// 		if (err) {
// 			callback(err);
// 			return;
// 		}
// 		callback(null, volume.substring(2));
// 	}, 'Unable to change the volume');
// }
// /**
//  * Decrease the volume by 0.5dB
//  *
//  * @param   function  callback
//  */
// denon.prototype.setVolumeDown = function (callback) {
// 	this.send('MVDOWN', new RegExp('[A-Z]{2}[0-9]{2,3}$'), function (err, volume) {
// 		if (err) {
// 			callback(err);
// 			return;
// 		}
// 		callback(null, volume.substring(2));
// 	}, 'Unable to change the volume');
// }
// /**
//  * Set the volume at a specific level (0-99)
//  *
//  * @param   int       level
//  * @param   function  callback
//  */
// denon.prototype.setVolumeAscii = function (level, callback) {
// 	this.send('MV' + level, new RegExp('[A-Z]{2}[0-9]{2,3}$'), function (err, volume) {
// 		if (err) {
// 			callback(err);
// 			return;
// 		}
// 		callback(null, volume.substring(2));
// 	}, 'Unable to change the volume');
// }
// /**
//  * Set the volume at a specific dB level (+1.0 to -80.5)
//  *
//  * @param   int       level
//  * @param   function  callback
//  */
// denon.prototype.setVolumeDb = function (level, callback) {
// 	level = this.parseDbVolume(level);
// 	this.send('MV' + level, new RegExp('[A-Z]{2}[0-9]{2,3}$'), function (err, volume) {
// 		if (err) {
// 			callback(err);
// 			return;
// 		}
// 		callback(null, volume.substring(2));
// 	}, 'Unable to change the volume');
// }
// /**
//  * Get the current volume level
//  *
//  * @param   function  callback
//  */
// denon.prototype.getVolumeLevel = function (callback) {
// 	this.send('MV?', new RegExp('[A-Z]{2}[0-9]{2,3}$'), function (err, volume) {
// 		if (err) {
// 			callback(err);
// 			return;
// 		}
// 		callback(null, volume.substring(2));
// 	}, 'Unable to get current volume');
// }
// /**
//  * Set the mute state
//  *
//  * @param   bool      state
//  * @param   function  callback
//  */
// denon.prototype.setMuteState = function (state, callback) {
// 	var cmd = 'MUOFF';
// 	if (state) {
// 		cmd = 'MUON';
// 	}
// 	this.send(cmd, 'MU', callback, 'Unable to change the mute status');
// }
// /**
//  * Get the current mute state
//  *
//  * @param   function  callback
//  */
// denon.prototype.getMuteState = function (callback) {
// 	this.send('MU?', 'MU', callback, 'Unable to get the current mute status');
// }
// /**
//  * Get the current source
//  *
//  * @param   function  callback
//  */
// denon.prototype.getSource = function (callback) {
// 	this.send('SI?', 'SI', callback, 'Unable to query current source');
// }
// /**
//  * Get the connection created in the transport layer
//  *
//  * @return  object
//  */
// denon.prototype.getConnection = function () {
// 	return this.getTransport().getConnection();
// }
// /**
//  * Parse the volume to dB
//  *
//  * @param   string    volume   As per docs, 50=0db, 505 = -0.5dB
//  * @return  double
//  */
// denon.prototype.parseAsciiVolume = function (volume, zero) {
// 	// if we havn't been provided with the 0dB value, assume it's 80
// 	// Master volume 80=0dB
// 	// Channel volume 50=0dB
// 	if (typeof zero === 'undefined') {
// 		zero = 80;
// 	}
// 	var halfdb = false;
// 	if (volume.length == 3) {
// 		halfdb = true;
// 		volume = volume.substring(0, 2);
// 	}
// 	volume = parseInt(volume) - zero;
// 	if (halfdb) {
// 		volume += 0.5;
// 	}
// 	return volume;
// }
// denon.prototype.parseDbVolume = function (volume, zero) {
// 	// if we havn't been provided with the 0dB value, assume it's 80
// 	// Master volume 80=0dB
// 	// Channel volume 50=0dB
// 	if (typeof zero === 'undefined') {
// 		zero = 80;
// 	}
// 	var halfdb = false;
// 	if (volume % 1 !== 0) {
// 		halfdb = true;
// 		volume = Math.floor(volume);
// 	}
// 	volume = (volume + zero).toString();
// 	if (halfdb) {
// 		volume += '5';
// 	}
// 	return volume;
// }
// module.exports = denon;
//# sourceMappingURL=denon.js.map