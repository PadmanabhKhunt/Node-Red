
            <script type='text/javascript'>
              {
                function render (node, options) {
                  try {
                    if (typeof node !== 'object') {
                      return
                    }
                    let minWidth = '400px'
                    if (options) {
                      if (options.minWidth) minWidth = options.minWidth
                    }
                    if (!node.__clone) {
                      node.__clone = window.$.extend(true, {}, node)
                    }
                    new Sqlite_plugin_red({
                      target: document.getElementById('sqlite-plugin-red-svelte-container'),
                      props: { node: node.__clone }
                    })
                    document.getElementById('sqlite-plugin-red-svelte-container').style.width = minWidth
                    const nodeIsSidebarTab = !node?._def?.oneditresize
                    if (!nodeIsSidebarTab) {
                      const orgResize = node._def.oneditresize
                      node._def.oneditresize = function (size) {
                        document.getElementById('sqlite-plugin-red-svelte-container').style.width = 'auto'
                        if (orgResize) orgResize(size)
                        node._def.oneditresize = orgResize
                      }
                    }
                  } catch (e) {
                      console.log(e)
                  }
                }
                function update (node) {
                  if (node.__clone) {
                    const clone = node.__clone
                    delete node.__clone
                    const defaultKeys = Object.keys(node._def.defaults)
                    for (const key of Object.keys(clone)) {
                      if (defaultKeys.indexOf(key) === -1) {
                        delete clone[key]
                      }
                    }
                    Object.assign(node, clone)
                  }
                }
                function revert (node) {
                  delete node.__clone
                }
                function noop() { }
const identity = x => x;
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function get_all_dirty_from_scope($$scope) {
    if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;
        for (let i = 0; i < length; i++) {
            dirty[i] = -1;
        }
        return dirty;
    }
    return -1;
}
function compute_slots(slots) {
    const result = {};
    for (const key in slots) {
        result[key] = true;
    }
    return result;
}
function null_to_empty(value) {
    return value == null ? '' : value;
}

const is_client = typeof window !== 'undefined';
let now = is_client
    ? () => window.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

const tasks = new Set();
function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}
function append(target, node) {
    target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
    const append_styles_to = get_root_for_style(target);
    if (!append_styles_to.getElementById(style_sheet_id)) {
        const style = element('style');
        style.id = style_sheet_id;
        style.textContent = styles;
        append_stylesheet(append_styles_to, style);
    }
}
function get_root_for_style(node) {
    if (!node)
        return document;
    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    if (root.host) {
        return root;
    }
    return document;
}
function append_empty_stylesheet(node) {
    const style_element = element('style');
    append_stylesheet(get_root_for_style(node), style_element);
    return style_element;
}
function append_stylesheet(node, style) {
    append(node.head || node, style);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function to_number(value) {
    return value === '' ? null : +value;
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_data(text, data) {
    data = '' + data;
    if (text.wholeText !== data)
        text.data = data;
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? 'important' : '');
}
function select_option(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        if (option.__value === value) {
            option.selected = true;
            return;
        }
    }
    select.selectedIndex = -1; // no option should be selected
}
function select_value(select) {
    const selected_option = select.querySelector(':checked') || select.options[0];
    return selected_option && selected_option.__value;
}
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail, bubbles = false) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, bubbles, false, detail);
    return e;
}

const active_docs = new Set();
let active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = get_root_for_style(node);
    active_docs.add(doc);
    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);
    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
    if (!current_rules[name]) {
        current_rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        active_docs.forEach(doc => {
            const stylesheet = doc.__svelte_stylesheet;
            let i = stylesheet.cssRules.length;
            while (i--)
                stylesheet.deleteRule(i);
            doc.__svelte_rules = {};
        });
        active_docs.clear();
    });
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail);
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
        }
    };
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        // @ts-ignore
        callbacks.slice().forEach(fn => fn.call(this, event));
    }
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update(component.$$);
        }
        set_current_component(null);
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
}
const null_transition = { duration: 0 };
function create_bidirectional_transition(node, fn, params, intro) {
    let config = fn(node, params);
    let t = intro ? 0 : 1;
    let running_program = null;
    let pending_program = null;
    let animation_name = null;
    function clear_animation() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function init(program, duration) {
        const d = (program.b - t);
        duration *= Math.abs(d);
        return {
            a: t,
            b: program.b,
            d,
            duration,
            start: program.start,
            end: program.start + duration,
            group: program.group
        };
    }
    function go(b) {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        const program = {
            start: now() + delay,
            b
        };
        if (!b) {
            // @ts-ignore todo: improve typings
            program.group = outros;
            outros.r += 1;
        }
        if (running_program || pending_program) {
            pending_program = program;
        }
        else {
            // if this is an intro, and there's a delay, we need to do
            // an initial tick and/or apply CSS animation immediately
            if (css) {
                clear_animation();
                animation_name = create_rule(node, t, b, duration, delay, easing, css);
            }
            if (b)
                tick(0, 1);
            running_program = init(program, duration);
            add_render_callback(() => dispatch(node, b, 'start'));
            loop(now => {
                if (pending_program && now > pending_program.start) {
                    running_program = init(pending_program, duration);
                    pending_program = null;
                    dispatch(node, running_program.b, 'start');
                    if (css) {
                        clear_animation();
                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                    }
                }
                if (running_program) {
                    if (now >= running_program.end) {
                        tick(t = running_program.b, 1 - t);
                        dispatch(node, running_program.b, 'end');
                        if (!pending_program) {
                            // we're done
                            if (running_program.b) {
                                // intro — we can tidy up immediately
                                clear_animation();
                            }
                            else {
                                // outro — needs to be coordinated
                                if (!--running_program.group.r)
                                    run_all(running_program.group.c);
                            }
                        }
                        running_program = null;
                    }
                    else if (now >= running_program.start) {
                        const p = now - running_program.start;
                        t = running_program.a + running_program.d * easing(p / running_program.duration);
                        tick(t, 1 - t);
                    }
                }
                return !!(running_program || pending_program);
            });
        }
    }
    return {
        run(b) {
            if (is_function(config)) {
                wait().then(() => {
                    // @ts-ignore
                    config = config();
                    go(b);
                });
            }
            else {
                go(b);
            }
        },
        end() {
            clear_animation();
            running_program = pending_program = null;
        }
    };
}

function destroy_block(block, lookup) {
    block.d(1);
    lookup.delete(block.key);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    return new_blocks;
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : options.context || []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

const getBooleanFrom = (property) => {
  return typeof property === 'boolean' ? property : property.toString().toLowerCase() === 'true'
};

const getId = (prop = null) => {
  let id = prop;
  if (!id) {
    id = Date.now() + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
  }
  return id
};

function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}

/* node_modules/svelte-integration-red/components/Row.svelte generated by Svelte v3.42.3 */

function add_css$9(target) {
	append_styles(target, "svelte-z33cig", ".sir-form-row.svelte-z33cig{clear:both;color:#555;margin-bottom:12px;display:flex;align-items:center;justify-content:flex-start}.sir-form-row > *:not(:last-child){margin-right:7px}.sir-form-row.inline button:not(:last-child){margin-right:3px}.sir-form-row label{display:inline-block;min-width:105px;width:105px;margin-right:7px;align-items:center;margin-bottom:0px;overflow-wrap:break-word}#red-ui-sidebar-content .sir-form-row :is(input, select, textarea){margin-bottom:0px}.red-ui-editor .sir-form-row input{height:auto}");
}

// (39:2) {#if indented}
function create_if_block$8(ctx) {
	let label;

	return {
		c() {
			label = element("label");
		},
		m(target, anchor) {
			insert(target, label, anchor);
		},
		d(detaching) {
			if (detaching) detach(label);
		}
	};
}

function create_fragment$9(ctx) {
	let div;
	let t;
	let div_class_value;
	let div_transition;
	let current;
	let if_block = /*indented*/ ctx[1] && create_if_block$8();
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			attr(div, "class", div_class_value = "" + (null_to_empty(/*clazz*/ ctx[3]) + " svelte-z33cig"));
			attr(div, "style", /*style*/ ctx[4]);
			toggle_class(div, "sir-form-row", !/*inline*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (/*indented*/ ctx[1]) {
				if (if_block) ; else {
					if_block = create_if_block$8();
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*clazz*/ 8 && div_class_value !== (div_class_value = "" + (null_to_empty(/*clazz*/ ctx[3]) + " svelte-z33cig"))) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 16) {
				attr(div, "style", /*style*/ ctx[4]);
			}

			if (dirty & /*clazz, inline*/ 9) {
				toggle_class(div, "sir-form-row", !/*inline*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: /*fading*/ ctx[2] ? 400 : 0 }, true);
				div_transition.run(1);
			});

			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: /*fading*/ ctx[2] ? 400 : 0 }, false);
			div_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			if (detaching && div_transition) div_transition.end();
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { clazz = '', style, inline = false, maximize = false, indented = false, fading = false } = $$props;
	inline = getBooleanFrom(inline);
	maximize = getBooleanFrom(maximize);
	fading = getBooleanFrom(fading);
	indented = getBooleanFrom(indented);

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(3, clazz = $$props.clazz);
		if ('style' in $$props) $$invalidate(4, style = $$props.style);
		if ('inline' in $$props) $$invalidate(0, inline = $$props.inline);
		if ('maximize' in $$props) $$invalidate(5, maximize = $$props.maximize);
		if ('indented' in $$props) $$invalidate(1, indented = $$props.indented);
		if ('fading' in $$props) $$invalidate(2, fading = $$props.fading);
		if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	return [inline, indented, fading, clazz, style, maximize, $$scope, slots];
}

class Row extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$9,
			create_fragment$9,
			safe_not_equal,
			{
				clazz: 3,
				style: 4,
				inline: 0,
				maximize: 5,
				indented: 1,
				fading: 2
			},
			add_css$9
		);
	}
}

/* global localStorage, */

// Translation:
// current way with Node-RED tools:
// - an i18nOptions object for the node where we can set a prefix if the Node-Red node is not in the main folder.
// - to translate in a SIR component object just set the node property and set the path within the json file, e.g.: label:{ label.name }.
// - instead of giving the node property you can set an i18n property with the path to the local folder, e.g.: 'test-node/second-node:' or if in the main folder: 'second-node:'
//
// a different approach to the code below is to use the offical way like:
// - direct i18n in html <span data-i18n="test-node/second-node:second-node.label.name"></span>
// - setting to placeholder prop <input type="text" data-i18n="[placeholder]myNode.placeholder.foo">
//
// Sidenote: This translation is only working for custom nodes. Translations for the sir components are within their files.
// This must be done that way, as we must ensure translation, whether SIR is installed or not. Also it seems that Node-Red only initialize translation files
// for nodes registered in the package.json.
// Addition: Since Node-Red 2.0.3 we can't import i18next as this will break all other translations.

const preferredLanguage = localStorage.getItem('editor-language') || navigator.language || 'en-US';

const i18nTranslate = (RED, node = {}, i18nDOM = true, translateThis) => {
  let result = translateThis;
  // i18n can be a string for the local folder path (which we can't have without node) or boolean false if we don't want to translate this one
  if (i18nDOM === false || i18nDOM.toString().trim() === 'false') {
    return result
  }

  let path = '';
  if (typeof i18nDOM === 'string') {
    path = i18nDOM;
  } else if (node) {
    path = node.type;
    let folder = node?._def?.i18nOptions?.folder;
    if (folder) {
      if (!folder.endsWith('/')) {
        folder += '/';
      }
      path = folder + path;
    }
  }
  if (path) {
    if (!path.endsWith(':')) path += ':';
    result = RED._(path + translateThis);
    // RED._() will replace colon with dot, so we have to check if result is like that pattern
    const translateColonReplacedWithDot = translateThis.replaceAll(':', '.');
    if (result === path + translateThis || result === path + translateColonReplacedWithDot || result === translateColonReplacedWithDot) {
      // couldn't find translation
      result = translateThis;
    }
  }
  return result
};

/* node_modules/svelte-integration-red/components/PlainInput.svelte generated by Svelte v3.42.3 */

function add_css$8(target) {
	append_styles(target, "svelte-1idal5v", ".maximize.svelte-1idal5v{width:100%}.label.svelte-1idal5v{min-width:100px;margin-bottom:5px}");
}

// (101:0) {:else}
function create_else_block_1$2(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error: No property name given.";
			attr(span, "class", "maximize svelte-1idal5v");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (72:0) {#if !updateNode || prop}
function create_if_block$7(ctx) {
	let t;
	let if_block1_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*type*/ ctx[3] !== 'checkbox' && /*label*/ ctx[1] || /*type*/ ctx[3] === 'checkbox' && /*label*/ ctx[1] && /*labelBeforeCheckbox*/ ctx[6]) return create_if_block_9$1;
		if (/*indented*/ ctx[5]) return create_if_block_11$1;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block0 = current_block_type && current_block_type(ctx);

	function select_block_type_2(ctx, dirty) {
		if (/*type*/ ctx[3] === 'text') return create_if_block_1$6;
		if (/*type*/ ctx[3] === 'number') return create_if_block_2$3;
		if (/*type*/ ctx[3] === 'password') return create_if_block_3$2;
		if (/*type*/ ctx[3] === 'email') return create_if_block_4$1;
		if (/*type*/ ctx[3] === 'url') return create_if_block_5$1;
		if (/*type*/ ctx[3] === 'checkbox') return create_if_block_6$1;
		return create_else_block$4;
	}

	let current_block_type_1 = select_block_type_2(ctx);
	let if_block1 = current_block_type_1(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if (if_block0) if_block0.d(1);
				if_block0 = current_block_type && current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(t.parentNode, t);
				}
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_2(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			}
		},
		d(detaching) {
			if (if_block0) {
				if_block0.d(detaching);
			}

			if (detaching) detach(t);
			if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

// (77:21) 
function create_if_block_11$1(ctx) {
	let label_1;

	return {
		c() {
			label_1 = element("label");
			set_style(label_1, "pointer", "cursor: initial");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(label_1);
		}
	};
}

// (73:2) {#if (type !== 'checkbox' && label) || (type === 'checkbox' && label && labelBeforeCheckbox)}
function create_if_block_9$1(ctx) {
	let label_1;
	let t0;
	let t1;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[4] && create_if_block_10$1(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[1]);
			attr(label_1, "for", /*inputId*/ ctx[12]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);

			if (!mounted) {
				dispose = [
					listen(label_1, "mouseenter", /*mouseenter_handler*/ ctx[33]),
					listen(label_1, "mouseleave", /*mouseleave_handler*/ ctx[34])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_10$1(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*label*/ 2) set_data(t1, /*label*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (75:6) {#if icon}
function create_if_block_10$1(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-1idal5v");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 16 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-1idal5v")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (98:2) {:else}
function create_else_block$4(ctx) {
	let span;
	let t0;
	let t1;
	let t2;

	return {
		c() {
			span = element("span");
			t0 = text("Error: Unsupported property type '");
			t1 = text(/*type*/ ctx[3]);
			t2 = text("'.");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
			append(span, t2);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*type*/ 8) set_data(t1, /*type*/ ctx[3]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (91:32) 
function create_if_block_6$1(ctx) {
	let div;
	let input;
	let t;
	let mounted;
	let dispose;
	let if_block = /*label*/ ctx[1] && !/*labelBeforeCheckbox*/ ctx[6] && create_if_block_7$1(ctx);

	return {
		c() {
			div = element("div");
			input = element("input");
			t = space();
			if (if_block) if_block.c();
			attr(input, "type", "checkbox");
			attr(input, "id", /*inputId*/ ctx[12]);
			input.disabled = /*disabled*/ ctx[7];
			toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			attr(div, "class", "checkbox");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, input);
			input.checked = /*value*/ ctx[0];
			append(div, t);
			if (if_block) if_block.m(div, null);

			if (!mounted) {
				dispose = [
					listen(input, "mouseenter", /*mouseenter_handler_6*/ ctx[31]),
					listen(input, "mouseleave", /*mouseleave_handler_6*/ ctx[32]),
					listen(input, "change", /*input_change_handler*/ ctx[40])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*disabled*/ 128) {
				input.disabled = /*disabled*/ ctx[7];
			}

			if (dirty[0] & /*value*/ 1) {
				input.checked = /*value*/ ctx[0];
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			}

			if (/*label*/ ctx[1] && !/*labelBeforeCheckbox*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_7$1(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (89:27) 
function create_if_block_5$1(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputId*/ ctx[12]);
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[7];
			attr(input, "type", "url");
			attr(input, "class", "svelte-1idal5v");
			toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "mouseenter", /*mouseenter_handler_5*/ ctx[27]),
					listen(input, "mouseleave", /*mouseleave_handler_5*/ ctx[28]),
					listen(input, "input", /*input_input_handler_4*/ ctx[39])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 128) {
				input.disabled = /*disabled*/ ctx[7];
			}

			if (dirty[0] & /*value*/ 1) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*maximize*/ 512) {
				toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (87:29) 
function create_if_block_4$1(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputId*/ ctx[12]);
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[7];
			attr(input, "type", "email");
			attr(input, "class", "svelte-1idal5v");
			toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "mouseenter", /*mouseenter_handler_4*/ ctx[25]),
					listen(input, "mouseleave", /*mouseleave_handler_4*/ ctx[26]),
					listen(input, "input", /*input_input_handler_3*/ ctx[38])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 128) {
				input.disabled = /*disabled*/ ctx[7];
			}

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*maximize*/ 512) {
				toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (85:32) 
function create_if_block_3$2(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputId*/ ctx[12]);
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[7];
			attr(input, "type", "password");
			attr(input, "class", "svelte-1idal5v");
			toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "mouseenter", /*mouseenter_handler_3*/ ctx[23]),
					listen(input, "mouseleave", /*mouseleave_handler_3*/ ctx[24]),
					listen(input, "input", /*input_input_handler_2*/ ctx[37])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 128) {
				input.disabled = /*disabled*/ ctx[7];
			}

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*maximize*/ 512) {
				toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (83:30) 
function create_if_block_2$3(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputId*/ ctx[12]);
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[7];
			attr(input, "type", "number");
			attr(input, "class", "svelte-1idal5v");
			toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "mouseenter", /*mouseenter_handler_2*/ ctx[21]),
					listen(input, "mouseleave", /*mouseleave_handler_2*/ ctx[22]),
					listen(input, "input", /*input_input_handler_1*/ ctx[36])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 128) {
				input.disabled = /*disabled*/ ctx[7];
			}

			if (dirty[0] & /*value*/ 1 && to_number(input.value) !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*maximize*/ 512) {
				toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (81:2) {#if type === 'text'}
function create_if_block_1$6(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputId*/ ctx[12]);
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[7];
			attr(input, "type", "text");
			attr(input, "class", "svelte-1idal5v");
			toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "mouseenter", /*mouseenter_handler_1*/ ctx[19]),
					listen(input, "mouseleave", /*mouseleave_handler_1*/ ctx[20]),
					listen(input, "input", /*input_input_handler*/ ctx[35])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 128) {
				input.disabled = /*disabled*/ ctx[7];
			}

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*maximize*/ 512) {
				toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (94:8) {#if label && !labelBeforeCheckbox}
function create_if_block_7$1(ctx) {
	let label_1;
	let t0;
	let t1;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[4] && create_if_block_8$1(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[1]);
			attr(label_1, "for", /*inputId*/ ctx[12]);
			set_style(label_1, "width", "100%");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);

			if (!mounted) {
				dispose = [
					listen(label_1, "mouseenter", /*mouseenter_handler_7*/ ctx[29]),
					listen(label_1, "mouseleave", /*mouseleave_handler_7*/ ctx[30])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_8$1(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*label*/ 2) set_data(t1, /*label*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (95:79) {#if icon}
function create_if_block_8$1(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-1idal5v");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 16 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-1idal5v")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

function create_fragment$8(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (!/*updateNode*/ ctx[11] || /*prop*/ ctx[8]) return create_if_block$7;
		return create_else_block_1$2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	let { node, prop, value, type, icon, credentials = false, indented = false, label, labelBeforeCheckbox = false, placeholder, maximize, id, disabled = false, i18n } = $$props;

	if (!id) {
		id = getId(prop);
	}

	credentials = getBooleanFrom(credentials);
	indented = getBooleanFrom(indented);
	disabled = getBooleanFrom(disabled);
	labelBeforeCheckbox = getBooleanFrom(labelBeforeCheckbox);
	let defaults;

	if (!node) {
		defaults = {};
	} else {
		defaults = credentials ? node._def.credentials : node._def.defaults;
	}

	const dispatch = createEventDispatcher();
	const updateNode = typeof node !== 'undefined';
	value = updateNode && node[prop] || value;
	let isValid = true;
	let init = true;
	icon = icon || defaults?.[prop]?.icon || '';

	if (label !== false) {
		label = label || defaults?.[prop]?.label || prop || '';
	}

	placeholder = placeholder || defaults?.[prop]?.placeholder || '';

	if (!type) {
		let testValue = defaults[prop] ? defaults[prop].value : value;

		if (typeof testValue === 'number') {
			type = 'number';
		} else if (typeof testValue === 'boolean') {
			type = 'checkbox';
		} else {
			type = 'text';
		}
	}

	let inputId = 'node-input-' + id;

	function mouseenter_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_7(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_7(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_6(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_6(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_input_handler_1() {
		value = to_number(this.value);
		$$invalidate(0, value);
	}

	function input_input_handler_2() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_input_handler_3() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_input_handler_4() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_change_handler() {
		value = this.checked;
		$$invalidate(0, value);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(13, node = $$props.node);
		if ('prop' in $$props) $$invalidate(8, prop = $$props.prop);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('type' in $$props) $$invalidate(3, type = $$props.type);
		if ('icon' in $$props) $$invalidate(4, icon = $$props.icon);
		if ('credentials' in $$props) $$invalidate(15, credentials = $$props.credentials);
		if ('indented' in $$props) $$invalidate(5, indented = $$props.indented);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('labelBeforeCheckbox' in $$props) $$invalidate(6, labelBeforeCheckbox = $$props.labelBeforeCheckbox);
		if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
		if ('maximize' in $$props) $$invalidate(9, maximize = $$props.maximize);
		if ('id' in $$props) $$invalidate(14, id = $$props.id);
		if ('disabled' in $$props) $$invalidate(7, disabled = $$props.disabled);
		if ('i18n' in $$props) $$invalidate(16, i18n = $$props.i18n);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*defaults, prop, value, init, id*/ 409857) {
			{
				if (defaults?.[prop]?.validate) {
					$$invalidate(10, isValid = defaults?.[prop]?.validate(value));
				}

				if (updateNode) {
					$$invalidate(13, node[prop] = value, node);
				}

				if (!init) {
					dispatch('change', { id, value });
				}

				$$invalidate(18, init = false);
			}
		}

		if ($$self.$$.dirty[0] & /*label, node, i18n*/ 73730) {
			{
				if (label) {
					$$invalidate(1, label = i18nTranslate(RED, node, i18n, label));
				}
			}
		}

		if ($$self.$$.dirty[0] & /*placeholder, node, i18n*/ 73732) {
			{
				if (placeholder) {
					$$invalidate(2, placeholder = i18nTranslate(RED, node, i18n, placeholder));
				}
			}
		}
	};

	return [
		value,
		label,
		placeholder,
		type,
		icon,
		indented,
		labelBeforeCheckbox,
		disabled,
		prop,
		maximize,
		isValid,
		updateNode,
		inputId,
		node,
		id,
		credentials,
		i18n,
		defaults,
		init,
		mouseenter_handler_1,
		mouseleave_handler_1,
		mouseenter_handler_2,
		mouseleave_handler_2,
		mouseenter_handler_3,
		mouseleave_handler_3,
		mouseenter_handler_4,
		mouseleave_handler_4,
		mouseenter_handler_5,
		mouseleave_handler_5,
		mouseenter_handler_7,
		mouseleave_handler_7,
		mouseenter_handler_6,
		mouseleave_handler_6,
		mouseenter_handler,
		mouseleave_handler,
		input_input_handler,
		input_input_handler_1,
		input_input_handler_2,
		input_input_handler_3,
		input_input_handler_4,
		input_change_handler
	];
}

class PlainInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$8,
			create_fragment$8,
			safe_not_equal,
			{
				node: 13,
				prop: 8,
				value: 0,
				type: 3,
				icon: 4,
				credentials: 15,
				indented: 5,
				label: 1,
				labelBeforeCheckbox: 6,
				placeholder: 2,
				maximize: 9,
				id: 14,
				disabled: 7,
				i18n: 16
			},
			add_css$8,
			[-1, -1]
		);
	}
}

/* node_modules/svelte-integration-red/components/Button.svelte generated by Svelte v3.42.3 */

function add_css$7(target) {
	append_styles(target, "svelte-1dv5lek", ".sir-button.svelte-1dv5lek{width:fit-content}.minWidth.svelte-1dv5lek{min-width:33px}.red-ui-button-small.svelte-1dv5lek{min-width:21px}button.red-ui-button.sir-button:not(.primary):not(.disabled):not(:disabled):hover{background:#e0e0e0}.maximize.svelte-1dv5lek{width:100%}");
}

// (34:2) {#if indented}
function create_if_block_1$5(ctx) {
	let label_1;

	return {
		c() {
			label_1 = element("label");
			set_style(label_1, "pointer", "cursor: initial");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
		},
		d(detaching) {
			if (detaching) detach(label_1);
		}
	};
}

// (40:4) {#if icon}
function create_if_block$6(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[7] + " svelte-1dv5lek");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 128 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[7] + " svelte-1dv5lek")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (33:0) <Row inline={inline}>
function create_default_slot$5(ctx) {
	let t0;
	let button;
	let t1;
	let t2_value = (/*label*/ ctx[0] || '') + "";
	let t2;
	let mounted;
	let dispose;
	let if_block0 = /*indented*/ ctx[6] && create_if_block_1$5();
	let if_block1 = /*icon*/ ctx[7] && create_if_block$6(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			button = element("button");
			if (if_block1) if_block1.c();
			t1 = space();
			t2 = text(t2_value);
			attr(button, "id", /*id*/ ctx[1]);
			attr(button, "style", /*style*/ ctx[9]);
			button.disabled = /*disabled*/ ctx[3];
			attr(button, "type", "button");
			attr(button, "class", "red-ui-button sir-button svelte-1dv5lek");
			toggle_class(button, "maximize", /*maximize*/ ctx[4]);
			toggle_class(button, "selected", /*selected*/ ctx[10]);
			toggle_class(button, "red-ui-button-small", /*small*/ ctx[2]);
			toggle_class(button, "primary", /*primary*/ ctx[8] && !/*disabled*/ ctx[3]);
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, button, anchor);
			if (if_block1) if_block1.m(button, null);
			append(button, t1);
			append(button, t2);

			if (!mounted) {
				dispose = listen(button, "click", /*clickHandler*/ ctx[11]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*indented*/ ctx[6]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_1$5();
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*icon*/ ctx[7]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$6(ctx);
					if_block1.c();
					if_block1.m(button, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*label*/ 1 && t2_value !== (t2_value = (/*label*/ ctx[0] || '') + "")) set_data(t2, t2_value);

			if (dirty & /*id*/ 2) {
				attr(button, "id", /*id*/ ctx[1]);
			}

			if (dirty & /*style*/ 512) {
				attr(button, "style", /*style*/ ctx[9]);
			}

			if (dirty & /*disabled*/ 8) {
				button.disabled = /*disabled*/ ctx[3];
			}

			if (dirty & /*maximize*/ 16) {
				toggle_class(button, "maximize", /*maximize*/ ctx[4]);
			}

			if (dirty & /*selected*/ 1024) {
				toggle_class(button, "selected", /*selected*/ ctx[10]);
			}

			if (dirty & /*small*/ 4) {
				toggle_class(button, "red-ui-button-small", /*small*/ ctx[2]);
			}

			if (dirty & /*primary, disabled*/ 264) {
				toggle_class(button, "primary", /*primary*/ ctx[8] && !/*disabled*/ ctx[3]);
			}
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(button);
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$7(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				inline: /*inline*/ ctx[5],
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};
			if (dirty & /*inline*/ 32) row_changes.inline = /*inline*/ ctx[5];

			if (dirty & /*$$scope, id, style, disabled, maximize, selected, small, primary, label, icon, indented*/ 34783) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let { node, id, icon, label, small = false, disabled = false, primary = false, style, selected = false, maximize = false, inline = true, indented = false, i18n } = $$props;
	small = getBooleanFrom(small);
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);
	inline = getBooleanFrom(inline);
	indented = getBooleanFrom(indented);

	if (!id) {
		id = getId();
	}

	if (label) label = i18nTranslate(RED, node, i18n, label);
	const dispatch = createEventDispatcher();

	function clickHandler(event) {
		dispatch('click', event.details);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(12, node = $$props.node);
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('icon' in $$props) $$invalidate(7, icon = $$props.icon);
		if ('label' in $$props) $$invalidate(0, label = $$props.label);
		if ('small' in $$props) $$invalidate(2, small = $$props.small);
		if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ('primary' in $$props) $$invalidate(8, primary = $$props.primary);
		if ('style' in $$props) $$invalidate(9, style = $$props.style);
		if ('selected' in $$props) $$invalidate(10, selected = $$props.selected);
		if ('maximize' in $$props) $$invalidate(4, maximize = $$props.maximize);
		if ('inline' in $$props) $$invalidate(5, inline = $$props.inline);
		if ('indented' in $$props) $$invalidate(6, indented = $$props.indented);
		if ('i18n' in $$props) $$invalidate(13, i18n = $$props.i18n);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*label, node, i18n*/ 12289) {
			{
				if (label) {
					$$invalidate(0, label = i18nTranslate(RED, node, i18n, label));
				}
			}
		}
	};

	return [
		label,
		id,
		small,
		disabled,
		maximize,
		inline,
		indented,
		icon,
		primary,
		style,
		selected,
		clickHandler,
		node,
		i18n
	];
}

class Button extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$7,
			create_fragment$7,
			safe_not_equal,
			{
				node: 12,
				id: 1,
				icon: 7,
				label: 0,
				small: 2,
				disabled: 3,
				primary: 8,
				style: 9,
				selected: 10,
				maximize: 4,
				inline: 5,
				indented: 6,
				i18n: 13
			},
			add_css$7
		);
	}
}

/* node_modules/svelte-integration-red/components/ConfigNodeInput.svelte generated by Svelte v3.42.3 */

function add_css$6(target) {
	append_styles(target, "svelte-1grox8e", ".disabled.svelte-1grox8e{pointer-events:none}.maximize.svelte-1grox8e{width:100%}");
}

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i].id;
	child_ctx[3] = list[i].label;
	return child_ctx;
}

// (105:0) {:else}
function create_else_block$3(ctx) {
	let span;
	let t0;
	let t1;

	return {
		c() {
			span = element("span");
			t0 = text("Error: ");
			t1 = text(/*error*/ ctx[8]);
			attr(span, "class", "maximize svelte-1grox8e");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*error*/ 256) set_data(t1, /*error*/ ctx[8]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (95:0) {#if node && prop}
function create_if_block$5(ctx) {
	let label_1;
	let t0;
	let t1;
	let label_1_for_value;
	let t2;
	let select;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let select_id_value;
	let select_placeholder_value;
	let t3;
	let button;
	let current;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[6] && create_if_block_1$4(ctx);
	let each_value = /*configNodes*/ ctx[9];
	const get_key = ctx => /*id*/ ctx[4];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$2(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
	}

	button = new Button({
			props: {
				id: "node-input-lookup-" + /*prop*/ ctx[5],
				disabled: /*disabled*/ ctx[1],
				icon: "pencil"
			}
		});

	button.$on("click", /*editConfigNode*/ ctx[11]);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[3]);
			t2 = space();
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			create_component(button.$$.fragment);
			attr(label_1, "for", label_1_for_value = "node-input-" + /*prop*/ ctx[5]);
			attr(select, "id", select_id_value = "node-input-" + /*prop*/ ctx[5]);
			attr(select, "placeholder", select_placeholder_value = /*defaults*/ ctx[10][/*prop*/ ctx[5]].label);
			select.disabled = /*disabled*/ ctx[1];
			attr(select, "class", "svelte-1grox8e");
			if (/*selectedNode*/ ctx[7] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[16].call(select));
			toggle_class(select, "input-error", /*selectedNode*/ ctx[7] === '_ADD_');
			toggle_class(select, "maximize", /*maximize*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);
			insert(target, t2, anchor);
			insert(target, select, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*selectedNode*/ ctx[7]);
			insert(target, t3, anchor);
			mount_component(button, target, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen(select, "change", /*select_change_handler*/ ctx[16]),
					listen(select, "mouseenter", /*mouseenter_handler*/ ctx[14]),
					listen(select, "mouseleave", /*mouseleave_handler*/ ctx[15])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$4(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (!current || dirty & /*label*/ 8) set_data(t1, /*label*/ ctx[3]);

			if (!current || dirty & /*prop*/ 32 && label_1_for_value !== (label_1_for_value = "node-input-" + /*prop*/ ctx[5])) {
				attr(label_1, "for", label_1_for_value);
			}

			if (dirty & /*configNodes*/ 512) {
				each_value = /*configNodes*/ ctx[9];
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, select, destroy_block, create_each_block$2, null, get_each_context$2);
			}

			if (!current || dirty & /*prop*/ 32 && select_id_value !== (select_id_value = "node-input-" + /*prop*/ ctx[5])) {
				attr(select, "id", select_id_value);
			}

			if (!current || dirty & /*prop*/ 32 && select_placeholder_value !== (select_placeholder_value = /*defaults*/ ctx[10][/*prop*/ ctx[5]].label)) {
				attr(select, "placeholder", select_placeholder_value);
			}

			if (!current || dirty & /*disabled*/ 2) {
				select.disabled = /*disabled*/ ctx[1];
			}

			if (dirty & /*selectedNode, configNodes*/ 640) {
				select_option(select, /*selectedNode*/ ctx[7]);
			}

			if (dirty & /*selectedNode*/ 128) {
				toggle_class(select, "input-error", /*selectedNode*/ ctx[7] === '_ADD_');
			}

			if (dirty & /*maximize*/ 4) {
				toggle_class(select, "maximize", /*maximize*/ ctx[2]);
			}

			const button_changes = {};
			if (dirty & /*prop*/ 32) button_changes.id = "node-input-lookup-" + /*prop*/ ctx[5];
			if (dirty & /*disabled*/ 2) button_changes.disabled = /*disabled*/ ctx[1];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			if (detaching) detach(t2);
			if (detaching) detach(select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (detaching) detach(t3);
			destroy_component(button, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (96:33) {#if icon}
function create_if_block_1$4(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[6] + " svelte-1grox8e");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 64 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[6] + " svelte-1grox8e")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (100:6) {#each configNodes as { id, label }
function create_each_block$2(key_1, ctx) {
	let option;
	let t_value = /*label*/ ctx[3] + "";
	let t;
	let option_value_value;

	return {
		key: key_1,
		first: null,
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*id*/ ctx[4];
			option.value = option.__value;
			this.first = option;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*configNodes*/ 512 && t_value !== (t_value = /*label*/ ctx[3] + "")) set_data(t, t_value);

			if (dirty & /*configNodes*/ 512 && option_value_value !== (option_value_value = /*id*/ ctx[4])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

function create_fragment$6(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$5, create_else_block$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*node*/ ctx[0] && /*prop*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let { node, prop, icon, label, id, disabled = false, maximize = true, i18n } = $$props;

	if (!id) {
		id = getId(prop);
	}

	let error = '';
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);

	if (!node) {
		node = {};
		error = "No node property given.";
	} else if (!prop) {
		error = "No property name given.";
	}

	const dispatch = createEventDispatcher();
	let defaults = node._def.defaults;
	label = label || defaults[prop] && defaults[prop].label || prop;
	if (label) label = i18nTranslate(RED, node, i18n, label);
	let configNodes = [];
	let previouslySelectedNode = node[prop] || '_ADD_';
	let selectedNode = node[prop] || '_ADD_';

	function updateConfigNodes() {
		$$invalidate(9, configNodes = []);
		const type = defaults[prop].type;
		const node_def = RED.nodes.getType(type);

		RED.nodes.eachConfig(function (config) {
			if (config.type === type) {
				let label = '';

				if (typeof node_def.label === 'function') {
					label = node_def.label.call(config);
				} else {
					label = node_def.label;
				}

				configNodes.push({ id: config.id, label });
			}
		});

		$$invalidate(9, configNodes = [...configNodes, { id: '_ADD_', label: `Add new ${type}...` }]);
	}

	onMount(() => {
		updateConfigNodes();

		RED.events.on('nodes:add', e => {
			if (e.type === defaults[prop].type) {
				updateConfigNodes();
				$$invalidate(7, selectedNode = e.id);
			}
		});

		RED.events.on('nodes:change', e => {
			if (e.type === defaults[prop].type) {
				updateConfigNodes();
			}
		});

		RED.events.on('nodes:remove', e => {
			if (e.type === defaults[prop].type) {
				updateConfigNodes();

				// Always select '_ADD_' after deleting (standard behaviour)
				// otherwise it breaks the node if only one other option was available
				$$invalidate(7, selectedNode = '_ADD_');
			}
		});
	});

	function editConfigNode() {
		// The prefix is omitted so the select gets updated by us and not by Node-RED
		RED.editor.editConfig(prop, defaults[prop].type, selectedNode); /*, 'node-input' */
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function select_change_handler() {
		selectedNode = select_value(this);
		$$invalidate(7, selectedNode);
		$$invalidate(9, configNodes);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(0, node = $$props.node);
		if ('prop' in $$props) $$invalidate(5, prop = $$props.prop);
		if ('icon' in $$props) $$invalidate(6, icon = $$props.icon);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('id' in $$props) $$invalidate(4, id = $$props.id);
		if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ('maximize' in $$props) $$invalidate(2, maximize = $$props.maximize);
		if ('i18n' in $$props) $$invalidate(12, i18n = $$props.i18n);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*selectedNode, previouslySelectedNode, prop*/ 8352) {
			{
				if (selectedNode !== previouslySelectedNode) {
					$$invalidate(0, node[prop] = selectedNode, node);

					dispatch('change', {
						before: previouslySelectedNode,
						after: selectedNode
					});

					$$invalidate(13, previouslySelectedNode = selectedNode);
				}
			}
		}
	};

	return [
		node,
		disabled,
		maximize,
		label,
		id,
		prop,
		icon,
		selectedNode,
		error,
		configNodes,
		defaults,
		editConfigNode,
		i18n,
		previouslySelectedNode,
		mouseenter_handler,
		mouseleave_handler,
		select_change_handler
	];
}

class ConfigNodeInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$6,
			create_fragment$6,
			safe_not_equal,
			{
				node: 0,
				prop: 5,
				icon: 6,
				label: 3,
				id: 4,
				disabled: 1,
				maximize: 2,
				i18n: 12
			},
			add_css$6
		);
	}
}

/* node_modules/svelte-integration-red/components/Input.svelte generated by Svelte v3.42.3 */

function add_css$5(target) {
	append_styles(target, "svelte-1owxzix", ".sir-input{display:inline-flex;align-items:center;width:100%}");
}

// (42:2) {:else}
function create_else_block$2(ctx) {
	let plaininput;
	let updating_node;
	let updating_prop;
	let updating_icon;
	let updating_label;
	let updating_disabled;
	let updating_value;
	let updating_type;
	let updating_placeholder;
	let updating_maximize;
	let current;

	function plaininput_node_binding(value) {
		/*plaininput_node_binding*/ ctx[22](value);
	}

	function plaininput_prop_binding(value) {
		/*plaininput_prop_binding*/ ctx[23](value);
	}

	function plaininput_icon_binding(value) {
		/*plaininput_icon_binding*/ ctx[24](value);
	}

	function plaininput_label_binding(value) {
		/*plaininput_label_binding*/ ctx[25](value);
	}

	function plaininput_disabled_binding(value) {
		/*plaininput_disabled_binding*/ ctx[26](value);
	}

	function plaininput_value_binding(value) {
		/*plaininput_value_binding*/ ctx[27](value);
	}

	function plaininput_type_binding(value) {
		/*plaininput_type_binding*/ ctx[28](value);
	}

	function plaininput_placeholder_binding(value) {
		/*plaininput_placeholder_binding*/ ctx[29](value);
	}

	function plaininput_maximize_binding(value) {
		/*plaininput_maximize_binding*/ ctx[30](value);
	}

	let plaininput_props = {
		i18n: /*i18n*/ ctx[13],
		indented: /*indented*/ ctx[9],
		credentials: /*credentials*/ ctx[11],
		id: /*id*/ ctx[12]
	};

	if (/*node*/ ctx[2] !== void 0) {
		plaininput_props.node = /*node*/ ctx[2];
	}

	if (/*prop*/ ctx[3] !== void 0) {
		plaininput_props.prop = /*prop*/ ctx[3];
	}

	if (/*icon*/ ctx[4] !== void 0) {
		plaininput_props.icon = /*icon*/ ctx[4];
	}

	if (/*label*/ ctx[5] !== void 0) {
		plaininput_props.label = /*label*/ ctx[5];
	}

	if (/*disabled*/ ctx[10] !== void 0) {
		plaininput_props.disabled = /*disabled*/ ctx[10];
	}

	if (/*value*/ ctx[0] !== void 0) {
		plaininput_props.value = /*value*/ ctx[0];
	}

	if (/*type*/ ctx[1] !== void 0) {
		plaininput_props.type = /*type*/ ctx[1];
	}

	if (/*placeholder*/ ctx[6] !== void 0) {
		plaininput_props.placeholder = /*placeholder*/ ctx[6];
	}

	if (/*maximize*/ ctx[8] !== void 0) {
		plaininput_props.maximize = /*maximize*/ ctx[8];
	}

	plaininput = new PlainInput({ props: plaininput_props });
	binding_callbacks.push(() => bind(plaininput, 'node', plaininput_node_binding));
	binding_callbacks.push(() => bind(plaininput, 'prop', plaininput_prop_binding));
	binding_callbacks.push(() => bind(plaininput, 'icon', plaininput_icon_binding));
	binding_callbacks.push(() => bind(plaininput, 'label', plaininput_label_binding));
	binding_callbacks.push(() => bind(plaininput, 'disabled', plaininput_disabled_binding));
	binding_callbacks.push(() => bind(plaininput, 'value', plaininput_value_binding));
	binding_callbacks.push(() => bind(plaininput, 'type', plaininput_type_binding));
	binding_callbacks.push(() => bind(plaininput, 'placeholder', plaininput_placeholder_binding));
	binding_callbacks.push(() => bind(plaininput, 'maximize', plaininput_maximize_binding));
	plaininput.$on("change", /*change_handler_1*/ ctx[31]);
	plaininput.$on("mouseenter", /*mouseenter_handler_1*/ ctx[32]);
	plaininput.$on("mouseleave", /*mouseleave_handler_1*/ ctx[33]);

	return {
		c() {
			create_component(plaininput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(plaininput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const plaininput_changes = {};
			if (dirty[0] & /*i18n*/ 8192) plaininput_changes.i18n = /*i18n*/ ctx[13];
			if (dirty[0] & /*indented*/ 512) plaininput_changes.indented = /*indented*/ ctx[9];
			if (dirty[0] & /*credentials*/ 2048) plaininput_changes.credentials = /*credentials*/ ctx[11];
			if (dirty[0] & /*id*/ 4096) plaininput_changes.id = /*id*/ ctx[12];

			if (!updating_node && dirty[0] & /*node*/ 4) {
				updating_node = true;
				plaininput_changes.node = /*node*/ ctx[2];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_prop && dirty[0] & /*prop*/ 8) {
				updating_prop = true;
				plaininput_changes.prop = /*prop*/ ctx[3];
				add_flush_callback(() => updating_prop = false);
			}

			if (!updating_icon && dirty[0] & /*icon*/ 16) {
				updating_icon = true;
				plaininput_changes.icon = /*icon*/ ctx[4];
				add_flush_callback(() => updating_icon = false);
			}

			if (!updating_label && dirty[0] & /*label*/ 32) {
				updating_label = true;
				plaininput_changes.label = /*label*/ ctx[5];
				add_flush_callback(() => updating_label = false);
			}

			if (!updating_disabled && dirty[0] & /*disabled*/ 1024) {
				updating_disabled = true;
				plaininput_changes.disabled = /*disabled*/ ctx[10];
				add_flush_callback(() => updating_disabled = false);
			}

			if (!updating_value && dirty[0] & /*value*/ 1) {
				updating_value = true;
				plaininput_changes.value = /*value*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			if (!updating_type && dirty[0] & /*type*/ 2) {
				updating_type = true;
				plaininput_changes.type = /*type*/ ctx[1];
				add_flush_callback(() => updating_type = false);
			}

			if (!updating_placeholder && dirty[0] & /*placeholder*/ 64) {
				updating_placeholder = true;
				plaininput_changes.placeholder = /*placeholder*/ ctx[6];
				add_flush_callback(() => updating_placeholder = false);
			}

			if (!updating_maximize && dirty[0] & /*maximize*/ 256) {
				updating_maximize = true;
				plaininput_changes.maximize = /*maximize*/ ctx[8];
				add_flush_callback(() => updating_maximize = false);
			}

			plaininput.$set(plaininput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(plaininput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(plaininput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(plaininput, detaching);
		}
	};
}

// (40:2) {#if type === 'config'}
function create_if_block$4(ctx) {
	let confignodeinput;
	let updating_node;
	let updating_prop;
	let updating_label;
	let updating_disabled;
	let current;

	function confignodeinput_node_binding(value) {
		/*confignodeinput_node_binding*/ ctx[15](value);
	}

	function confignodeinput_prop_binding(value) {
		/*confignodeinput_prop_binding*/ ctx[16](value);
	}

	function confignodeinput_label_binding(value) {
		/*confignodeinput_label_binding*/ ctx[17](value);
	}

	function confignodeinput_disabled_binding(value) {
		/*confignodeinput_disabled_binding*/ ctx[18](value);
	}

	let confignodeinput_props = {
		icon: /*icon*/ ctx[4],
		i18n: /*i18n*/ ctx[13],
		indented: /*indented*/ ctx[9]
	};

	if (/*node*/ ctx[2] !== void 0) {
		confignodeinput_props.node = /*node*/ ctx[2];
	}

	if (/*prop*/ ctx[3] !== void 0) {
		confignodeinput_props.prop = /*prop*/ ctx[3];
	}

	if (/*label*/ ctx[5] !== void 0) {
		confignodeinput_props.label = /*label*/ ctx[5];
	}

	if (/*disabled*/ ctx[10] !== void 0) {
		confignodeinput_props.disabled = /*disabled*/ ctx[10];
	}

	confignodeinput = new ConfigNodeInput({ props: confignodeinput_props });
	binding_callbacks.push(() => bind(confignodeinput, 'node', confignodeinput_node_binding));
	binding_callbacks.push(() => bind(confignodeinput, 'prop', confignodeinput_prop_binding));
	binding_callbacks.push(() => bind(confignodeinput, 'label', confignodeinput_label_binding));
	binding_callbacks.push(() => bind(confignodeinput, 'disabled', confignodeinput_disabled_binding));
	confignodeinput.$on("change", /*change_handler*/ ctx[19]);
	confignodeinput.$on("mouseenter", /*mouseenter_handler*/ ctx[20]);
	confignodeinput.$on("mouseleave", /*mouseleave_handler*/ ctx[21]);

	return {
		c() {
			create_component(confignodeinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(confignodeinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const confignodeinput_changes = {};
			if (dirty[0] & /*icon*/ 16) confignodeinput_changes.icon = /*icon*/ ctx[4];
			if (dirty[0] & /*i18n*/ 8192) confignodeinput_changes.i18n = /*i18n*/ ctx[13];
			if (dirty[0] & /*indented*/ 512) confignodeinput_changes.indented = /*indented*/ ctx[9];

			if (!updating_node && dirty[0] & /*node*/ 4) {
				updating_node = true;
				confignodeinput_changes.node = /*node*/ ctx[2];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_prop && dirty[0] & /*prop*/ 8) {
				updating_prop = true;
				confignodeinput_changes.prop = /*prop*/ ctx[3];
				add_flush_callback(() => updating_prop = false);
			}

			if (!updating_label && dirty[0] & /*label*/ 32) {
				updating_label = true;
				confignodeinput_changes.label = /*label*/ ctx[5];
				add_flush_callback(() => updating_label = false);
			}

			if (!updating_disabled && dirty[0] & /*disabled*/ 1024) {
				updating_disabled = true;
				confignodeinput_changes.disabled = /*disabled*/ ctx[10];
				add_flush_callback(() => updating_disabled = false);
			}

			confignodeinput.$set(confignodeinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(confignodeinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(confignodeinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(confignodeinput, detaching);
		}
	};
}

// (39:0) <Row clazz="sir-input" {inline} {maximize}>
function create_default_slot$4(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$4, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*type*/ ctx[1] === 'config') return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$5(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				clazz: "sir-input",
				inline: /*inline*/ ctx[7],
				maximize: /*maximize*/ ctx[8],
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};
			if (dirty[0] & /*inline*/ 128) row_changes.inline = /*inline*/ ctx[7];
			if (dirty[0] & /*maximize*/ 256) row_changes.maximize = /*maximize*/ ctx[8];

			if (dirty[0] & /*icon, i18n, indented, node, prop, label, disabled, type, credentials, id, value, placeholder, maximize*/ 16255 | dirty[1] & /*$$scope*/ 8) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let { node, prop, value, type, icon, credentials, label, placeholder, id, inline = false, maximize = true, indented = false, checked, disabled = false, i18n } = $$props;
	inline = getBooleanFrom(inline);
	maximize = getBooleanFrom(maximize);
	disabled = getBooleanFrom(disabled);
	indented = getBooleanFrom(indented);

	// loading node: if only node is bound for any input field in the svelte code, value would be undefined if the input field is empty or false
	if (type !== 'checkbox' && typeof value === 'undefined' && typeof node?.[prop] !== 'undefined') {
		value = node[prop];
	} else if (type === 'checkbox' && typeof value === 'undefined') {
		// special case for checkbox: bind:checked (offical property) could also be used and has prio before getting it possibly from node[prop]
		if (typeof checked !== 'undefined') {
			value = getBooleanFrom(checked);
		} else if (typeof node?.[prop] !== 'undefined') {
			value = getBooleanFrom(node[prop]);
		}
	}

	function confignodeinput_node_binding(value) {
		node = value;
		$$invalidate(2, node);
	}

	function confignodeinput_prop_binding(value) {
		prop = value;
		$$invalidate(3, prop);
	}

	function confignodeinput_label_binding(value) {
		label = value;
		$$invalidate(5, label);
	}

	function confignodeinput_disabled_binding(value) {
		disabled = value;
		$$invalidate(10, disabled);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function plaininput_node_binding(value) {
		node = value;
		$$invalidate(2, node);
	}

	function plaininput_prop_binding(value) {
		prop = value;
		$$invalidate(3, prop);
	}

	function plaininput_icon_binding(value) {
		icon = value;
		$$invalidate(4, icon);
	}

	function plaininput_label_binding(value) {
		label = value;
		$$invalidate(5, label);
	}

	function plaininput_disabled_binding(value) {
		disabled = value;
		$$invalidate(10, disabled);
	}

	function plaininput_value_binding(value$1) {
		value = value$1;
		$$invalidate(0, value);
	}

	function plaininput_type_binding(value) {
		type = value;
		$$invalidate(1, type);
	}

	function plaininput_placeholder_binding(value) {
		placeholder = value;
		$$invalidate(6, placeholder);
	}

	function plaininput_maximize_binding(value) {
		maximize = value;
		$$invalidate(8, maximize);
	}

	function change_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(2, node = $$props.node);
		if ('prop' in $$props) $$invalidate(3, prop = $$props.prop);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('type' in $$props) $$invalidate(1, type = $$props.type);
		if ('icon' in $$props) $$invalidate(4, icon = $$props.icon);
		if ('credentials' in $$props) $$invalidate(11, credentials = $$props.credentials);
		if ('label' in $$props) $$invalidate(5, label = $$props.label);
		if ('placeholder' in $$props) $$invalidate(6, placeholder = $$props.placeholder);
		if ('id' in $$props) $$invalidate(12, id = $$props.id);
		if ('inline' in $$props) $$invalidate(7, inline = $$props.inline);
		if ('maximize' in $$props) $$invalidate(8, maximize = $$props.maximize);
		if ('indented' in $$props) $$invalidate(9, indented = $$props.indented);
		if ('checked' in $$props) $$invalidate(14, checked = $$props.checked);
		if ('disabled' in $$props) $$invalidate(10, disabled = $$props.disabled);
		if ('i18n' in $$props) $$invalidate(13, i18n = $$props.i18n);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*type, checked, value*/ 16387) {
			// if checkbox has checked bound it must be updated with the value property (needed)
			if (type === 'checkbox' && typeof checked !== 'undefined' && typeof value !== 'undefined') {
				$$invalidate(14, checked = getBooleanFrom(value));
			}
		}
	};

	return [
		value,
		type,
		node,
		prop,
		icon,
		label,
		placeholder,
		inline,
		maximize,
		indented,
		disabled,
		credentials,
		id,
		i18n,
		checked,
		confignodeinput_node_binding,
		confignodeinput_prop_binding,
		confignodeinput_label_binding,
		confignodeinput_disabled_binding,
		change_handler,
		mouseenter_handler,
		mouseleave_handler,
		plaininput_node_binding,
		plaininput_prop_binding,
		plaininput_icon_binding,
		plaininput_label_binding,
		plaininput_disabled_binding,
		plaininput_value_binding,
		plaininput_type_binding,
		plaininput_placeholder_binding,
		plaininput_maximize_binding,
		change_handler_1,
		mouseenter_handler_1,
		mouseleave_handler_1
	];
}

class Input extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$5,
			create_fragment$5,
			safe_not_equal,
			{
				node: 2,
				prop: 3,
				value: 0,
				type: 1,
				icon: 4,
				credentials: 11,
				label: 5,
				placeholder: 6,
				id: 12,
				inline: 7,
				maximize: 8,
				indented: 9,
				checked: 14,
				disabled: 10,
				i18n: 13
			},
			add_css$5,
			[-1, -1]
		);
	}
}

/* node_modules/svelte-integration-red/components/Select.svelte generated by Svelte v3.42.3 */

function add_css$4(target) {
	append_styles(target, "svelte-msdd66", ".disabled.svelte-msdd66{pointer-events:none}.maximize.svelte-msdd66{width:100%}.sir-input select, .sir-select select{padding-left:3px}.sir-select{display:inline-flex;width:100%;align-items:center}");
}

// (50:2) {#if label}
function create_if_block$3(ctx) {
	let label_1;
	let t0;
	let t1;
	let label_1_for_value;
	let if_block = /*icon*/ ctx[8] && create_if_block_1$3(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[3]);
			attr(label_1, "for", label_1_for_value = "node-input-" + /*id*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[8]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$3(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*label*/ 8) set_data(t1, /*label*/ ctx[3]);

			if (dirty & /*id*/ 16 && label_1_for_value !== (label_1_for_value = "node-input-" + /*id*/ ctx[4])) {
				attr(label_1, "for", label_1_for_value);
			}
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
		}
	};
}

// (51:33) {#if icon}
function create_if_block_1$3(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[8] + " svelte-msdd66");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 256 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[8] + " svelte-msdd66")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (49:0) <Row clazz="sir-select" {inline}>
function create_default_slot$3(ctx) {
	let t;
	let select;
	let select_id_value;
	let select_placeholder_value;
	let current;
	let mounted;
	let dispose;
	let if_block = /*label*/ ctx[3] && create_if_block$3(ctx);
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			select = element("select");
			if (default_slot) default_slot.c();
			attr(select, "id", select_id_value = "node-input-" + /*id*/ ctx[4]);
			select.disabled = /*disabled*/ ctx[5];
			attr(select, "placeholder", select_placeholder_value = /*node*/ ctx[1] && /*defaults*/ ctx[9][/*prop*/ ctx[7]].label || '');
			attr(select, "class", "svelte-msdd66");
			if (/*value*/ ctx[0] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[15].call(select));
			toggle_class(select, "maximize", /*maximize*/ ctx[6]);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			insert(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			select_option(select, /*value*/ ctx[0]);
			current = true;

			if (!mounted) {
				dispose = [
					listen(select, "change", /*select_change_handler*/ ctx[15]),
					listen(select, "mouseenter", /*mouseenter_handler*/ ctx[13]),
					listen(select, "mouseleave", /*mouseleave_handler*/ ctx[14])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[16],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*id*/ 16 && select_id_value !== (select_id_value = "node-input-" + /*id*/ ctx[4])) {
				attr(select, "id", select_id_value);
			}

			if (!current || dirty & /*disabled*/ 32) {
				select.disabled = /*disabled*/ ctx[5];
			}

			if (!current || dirty & /*node, prop*/ 130 && select_placeholder_value !== (select_placeholder_value = /*node*/ ctx[1] && /*defaults*/ ctx[9][/*prop*/ ctx[7]].label || '')) {
				attr(select, "placeholder", select_placeholder_value);
			}

			if (dirty & /*value*/ 1) {
				select_option(select, /*value*/ ctx[0]);
			}

			if (dirty & /*maximize*/ 64) {
				toggle_class(select, "maximize", /*maximize*/ ctx[6]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(select);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$4(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				clazz: "sir-select",
				inline: /*inline*/ ctx[2],
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};
			if (dirty & /*inline*/ 4) row_changes.inline = /*inline*/ ctx[2];

			if (dirty & /*$$scope, id, disabled, node, prop, value, maximize, label, icon*/ 66043) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { node, inline = false, prop, value, icon, label, id, disabled = false, maximize = true, i18n } = $$props;

	if (!id) {
		id = getId(prop);
	}

	inline = getBooleanFrom(inline);
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);
	const dispatch = createEventDispatcher();
	const updateNode = typeof node !== 'undefined';
	value = updateNode && node[prop] || value;
	let init = true;
	let defaults = node ? node._def.defaults : {};
	if (label !== false) label = label || node && (defaults[prop] && defaults[prop].label || prop);

	if (label) {
		label = i18nTranslate(RED, node, i18n, label);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function select_change_handler() {
		value = select_value(this);
		$$invalidate(0, value);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(1, node = $$props.node);
		if ('inline' in $$props) $$invalidate(2, inline = $$props.inline);
		if ('prop' in $$props) $$invalidate(7, prop = $$props.prop);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('icon' in $$props) $$invalidate(8, icon = $$props.icon);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('id' in $$props) $$invalidate(4, id = $$props.id);
		if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
		if ('maximize' in $$props) $$invalidate(6, maximize = $$props.maximize);
		if ('i18n' in $$props) $$invalidate(10, i18n = $$props.i18n);
		if ('$$scope' in $$props) $$invalidate(16, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*prop, value, init*/ 2177) {
			{
				if (updateNode) {
					$$invalidate(1, node[prop] = value, node);
				}

				if (!init) {
					dispatch('change', { value });
				}

				$$invalidate(11, init = false);
			}
		}
	};

	return [
		value,
		node,
		inline,
		label,
		id,
		disabled,
		maximize,
		prop,
		icon,
		defaults,
		i18n,
		init,
		slots,
		mouseenter_handler,
		mouseleave_handler,
		select_change_handler,
		$$scope
	];
}

class Select extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$4,
			create_fragment$4,
			safe_not_equal,
			{
				node: 1,
				inline: 2,
				prop: 7,
				value: 0,
				icon: 8,
				label: 3,
				id: 4,
				disabled: 5,
				maximize: 6,
				i18n: 10
			},
			add_css$4
		);
	}
}

/* node_modules/svelte-integration-red/components/Callout.svelte generated by Svelte v3.42.3 */

function add_css$3(target) {
	append_styles(target, "svelte-5w7qty", ".sir-form-row.sir-callout{display:flex;align-items:center;margin:16px 0px;border-left-width:5px;border-left-style:solid;border-left-color:#7e7e7e;background-color:#e4e4e4;color:#202020}.sir-callout-icon.svelte-5w7qty.svelte-5w7qty{padding-left:30px;margin-right:0px}.sir-callout-icon.svelte-5w7qty i.svelte-5w7qty{font-size:3em;min-width:50px}.sir-callout-content.svelte-5w7qty.svelte-5w7qty{display:flex;flex-direction:column;flex-wrap:wrap;padding:15px}.hasButton.svelte-5w7qty.svelte-5w7qty{padding-right:5px}.close-button.svelte-5w7qty.svelte-5w7qty{margin-bottom:auto;margin-left:auto;margin-top:6px;margin-right:6px}.sir-form-row.sir-callout.info{border-left-color:#0288D1;background-color:#d3efff;color:#015380}.sir-form-row.sir-callout.warning{border-left-color:#e27b41;background-color:#faeae0;color:#b6531c}.sir-form-row.sir-callout.error{border-left-color:#E84F4F;background-color:#fce8e8;color:#b91818}.sir-form-row.sir-callout.success{border-left-color:#52A256;background-color:#e7f3e7;color:#376c39}.sir-callout :is(h1, h2, h3, h4, h5, h6){margin-top:0px;margin-bottom:10px\n  }");
}

const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({});

// (108:0) {#if show}
function create_if_block$2(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				clazz: "sir-callout " + /*type*/ ctx[0],
				id: /*id*/ ctx[1],
				fading: true,
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};
			if (dirty & /*type*/ 1) row_changes.clazz = "sir-callout " + /*type*/ ctx[0];
			if (dirty & /*id*/ 2) row_changes.id = /*id*/ ctx[1];

			if (dirty & /*$$scope, show, closeable, $$slots, icon*/ 572) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

// (112:6) {#if $$slots.header}
function create_if_block_2$2(ctx) {
	let h2;
	let current;
	const header_slot_template = /*#slots*/ ctx[7].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[9], get_header_slot_context);

	return {
		c() {
			h2 = element("h2");
			if (header_slot) header_slot.c();
		},
		m(target, anchor) {
			insert(target, h2, anchor);

			if (header_slot) {
				header_slot.m(h2, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[9], dirty, get_header_slot_changes),
						get_header_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h2);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (117:4) {#if closeable}
function create_if_block_1$2(ctx) {
	let div;
	let button;
	let current;
	button = new Button({ props: { icon: "close" } });
	button.$on("click", /*click_handler*/ ctx[8]);

	return {
		c() {
			div = element("div");
			create_component(button.$$.fragment);
			attr(div, "class", "close-button svelte-5w7qty");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(button);
		}
	};
}

// (109:2) <Row clazz={"sir-callout " + type} id={id} fading>
function create_default_slot$2(ctx) {
	let div0;
	let i;
	let i_class_value;
	let t0;
	let div1;
	let t1;
	let t2;
	let if_block1_anchor;
	let current;
	let if_block0 = /*$$slots*/ ctx[5].header && create_if_block_2$2(ctx);
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
	let if_block1 = /*closeable*/ ctx[3] && create_if_block_1$2(ctx);

	return {
		c() {
			div0 = element("div");
			i = element("i");
			t0 = space();
			div1 = element("div");
			if (if_block0) if_block0.c();
			t1 = space();
			if (default_slot) default_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			attr(i, "class", i_class_value = "" + (null_to_empty(/*icon*/ ctx[2]) + " svelte-5w7qty"));
			attr(div0, "class", "sir-callout-icon svelte-5w7qty");
			attr(div1, "class", "sir-callout-content svelte-5w7qty");
			toggle_class(div1, "hasButton", /*closeable*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			append(div0, i);
			insert(target, t0, anchor);
			insert(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t1);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			insert(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*icon*/ 4 && i_class_value !== (i_class_value = "" + (null_to_empty(/*icon*/ ctx[2]) + " svelte-5w7qty"))) {
				attr(i, "class", i_class_value);
			}

			if (/*$$slots*/ ctx[5].header) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*$$slots*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
						null
					);
				}
			}

			if (dirty & /*closeable*/ 8) {
				toggle_class(div1, "hasButton", /*closeable*/ ctx[3]);
			}

			if (/*closeable*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*closeable*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (detaching) detach(t0);
			if (detaching) detach(div1);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

function create_fragment$3(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*show*/ ctx[4] && create_if_block$2(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*show*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*show*/ 16) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { id, icon, type = '', closeable = false, show = true } = $$props;

	if (!id) {
		id = getId();
	}

	closeable = getBooleanFrom(closeable);
	shoe = getBooleanFrom(show);
	if (type === 'danger') type = 'error';
	let customIcon = false;

	if (icon) {
		customIcon = true;
		icon = icon.trim();

		if (!icon.startsWith('fa fa-')) {
			if (icon.startsWith('fa-')) icon = 'fa ' + icon; else icon = 'fa fa-' + icon;
		}
	}

	const click_handler = () => $$invalidate(4, show = false);

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('icon' in $$props) $$invalidate(2, icon = $$props.icon);
		if ('type' in $$props) $$invalidate(0, type = $$props.type);
		if ('closeable' in $$props) $$invalidate(3, closeable = $$props.closeable);
		if ('show' in $$props) $$invalidate(4, show = $$props.show);
		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*customIcon, type*/ 65) {
			{
				if (!customIcon) {
					switch (type) {
						case 'info':
							$$invalidate(2, icon = 'fa fa-info-circle');
							break;
						case 'warning':
							$$invalidate(2, icon = 'fa fa-exclamation-triangle');
							break;
						case 'error':
							$$invalidate(2, icon = 'fa fa-window-close');
							break;
						case 'success':
							$$invalidate(2, icon = 'fa fa-check-circle');
							break;
						default:
							$$invalidate(2, icon = 'fa fa-info-circle');
					}
				}
			}
		}
	};

	return [
		type,
		id,
		icon,
		closeable,
		show,
		$$slots,
		customIcon,
		slots,
		click_handler,
		$$scope
	];
}

class Callout extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$3,
			create_fragment$3,
			safe_not_equal,
			{
				id: 1,
				icon: 2,
				type: 0,
				closeable: 3,
				show: 4
			},
			add_css$3
		);
	}
}

/* node_modules/svelte-integration-red/components/Popup.svelte generated by Svelte v3.42.3 */

function add_css$2(target) {
	append_styles(target, "svelte-g2p1op", "#red-ui-notifications .ui-dialog-buttonset .disabled{pointer-events:none}.sir-popup-buttons.svelte-g2p1op{display:inline-flex;flex-direction:row;justify-content:flex-end;width:100%}.sir-popup-buttons div{display:inline-flex}");
}

const get_buttons_slot_changes = dirty => ({});
const get_buttons_slot_context = ctx => ({});

function create_fragment$2(ctx) {
	let div1;
	let t;
	let div0;
	let div1_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);
	const buttons_slot_template = /*#slots*/ ctx[14].buttons;
	const buttons_slot = create_slot(buttons_slot_template, ctx, /*$$scope*/ ctx[13], get_buttons_slot_context);

	return {
		c() {
			div1 = element("div");
			if (default_slot) default_slot.c();
			t = space();
			div0 = element("div");
			if (buttons_slot) buttons_slot.c();
			attr(div0, "class", "ui-dialog-buttonset sir-popup-buttons svelte-g2p1op");
			attr(div1, "class", div1_class_value = "" + (null_to_empty(/*classId*/ ctx[0]) + " svelte-g2p1op"));
			set_style(div1, "display", "none");
		},
		m(target, anchor) {
			insert(target, div1, anchor);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append(div1, t);
			append(div1, div0);

			if (buttons_slot) {
				buttons_slot.m(div0, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
						null
					);
				}
			}

			if (buttons_slot) {
				if (buttons_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					update_slot_base(
						buttons_slot,
						buttons_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(buttons_slot_template, /*$$scope*/ ctx[13], dirty, get_buttons_slot_changes),
						get_buttons_slot_context
					);
				}
			}

			if (!current || dirty & /*classId*/ 1 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*classId*/ ctx[0]) + " svelte-g2p1op"))) {
				attr(div1, "class", div1_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(buttons_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(buttons_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
			if (buttons_slot) buttons_slot.d(detaching);
		}
	};
}

let popupsKeys = new Map();

const closePopup = classId => {
	for (const element of document.getElementsByClassName(classId)) {
		if (element?.parentElement?.parentElement.id === 'red-ui-notifications') {
			element.parentElement.close();
		}
	}

	if (popupsKeys.has(classId)) {
		for (const key of popupsKeys.get(classId)) {
			RED.keyboard.remove(key);
		}
	}

	popupsKeys.delete(classId);
};

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { showPopup = false, id, fixed = false, timeout = 5000, modal = false, type = '', keyboard = {}, focus = '' } = $$props;
	showPopup = getBooleanFrom(showPopup);
	fixed = getBooleanFrom(fixed);
	modal = getBooleanFrom(modal);
	let classId = id;

	if (!classId) {
		classId = getId();
	}

	let popup;
	let multipleOpenings = true;
	let init = false;
	let addCloseButton = false;

	$$self.$$set = $$props => {
		if ('showPopup' in $$props) $$invalidate(1, showPopup = $$props.showPopup);
		if ('id' in $$props) $$invalidate(5, id = $$props.id);
		if ('fixed' in $$props) $$invalidate(2, fixed = $$props.fixed);
		if ('timeout' in $$props) $$invalidate(6, timeout = $$props.timeout);
		if ('modal' in $$props) $$invalidate(3, modal = $$props.modal);
		if ('type' in $$props) $$invalidate(7, type = $$props.type);
		if ('keyboard' in $$props) $$invalidate(8, keyboard = $$props.keyboard);
		if ('focus' in $$props) $$invalidate(4, focus = $$props.focus);
		if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*showPopup, classId, init, fixed, multipleOpenings, popup, keyboard, addCloseButton, modal, type, timeout, focus*/ 8159) {
			{
				if (showPopup) {
					// we use class instead of id due to multiple popups and we loose id by using RED.notify()
					// getting the popupContent must be done on first opening -> timing problem
					let popupContent = document.getElementsByClassName(classId)[0];

					// if we have some sort of input, we can only open the popup once per time (else one popup looses functions + multiple ID inputs etc.)
					if (!init && popupContent && (fixed || popupContent.getElementsByTagName('button').length || popupContent.getElementsByTagName('input').length || popupContent.getElementsByTagName('select').length)) {
						$$invalidate(10, multipleOpenings = false);
					}

					if (!init || !popupContent || popupContent && multipleOpenings) {
						if (fixed && popupContent && popupContent.getElementsByTagName('button').length === 0) {
							$$invalidate(12, addCloseButton = true);
						}

						// we must save the slot (DOM) as it will be deleted by closing the popup through Node-Red, if not fixed.
						// cloning does not work
						// current workaround: we put the whole DOM into popup variable to call it again
						if (!popup) {
							popupContent.style.display = 'initial';

							if (fixed) {
								$$invalidate(9, popup = popupContent);
							} else {
								$$invalidate(9, popup = popupContent.innerHTML);
								popupContent.remove(); // else it can also be shown outside the popup
							}
						}

						popupsKeys.set(classId, Object.keys(keyboard));
						const buttons = [];

						if (addCloseButton) {
							buttons.push({
								class: 'primary',
								text: 'Okay',
								click: () => nodeRedPopup.close()
							});
						}

						let nodeRedPopup = RED.notify(popup || 'No text stated!', { modal, fixed, type, timeout, buttons });
					}

					$$invalidate(11, init = true);

					for (const [key, f] of Object.entries(keyboard)) {
						RED.keyboard.add("*", key, f);
					}

					if (focus) {
						if (!focus.startsWith('node-input-')) {
							$$invalidate(4, focus = 'node-input-' + focus);
						}

						document.getElementById(focus).select();
						setTimeout(() => document.getElementById(focus).focus(), 100);
					}
				} else {
					for (const key of Object.keys(keyboard)) {
						RED.keyboard.remove(key);
					}
				}

				// the popup will stay on display, but we can call it immediately again
				$$invalidate(1, showPopup = false);
			}
		}
	};

	return [
		classId,
		showPopup,
		fixed,
		modal,
		focus,
		id,
		timeout,
		type,
		keyboard,
		popup,
		multipleOpenings,
		init,
		addCloseButton,
		$$scope,
		slots
	];
}

class Popup extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$2,
			create_fragment$2,
			safe_not_equal,
			{
				showPopup: 1,
				id: 5,
				fixed: 2,
				timeout: 6,
				modal: 3,
				type: 7,
				keyboard: 8,
				focus: 4
			},
			add_css$2
		);
	}
}

/* node_modules/svelte-integration-red/components/Table.svelte generated by Svelte v3.42.3 */

function add_css$1(target) {
	append_styles(target, "svelte-1d26vpt", "table.svelte-1d26vpt{width:100%}tr.svelte-1d26vpt:nth-child(even){background:#EFEFEF}tr.svelte-1d26vpt:nth-child(odd){background:#FFF}tr.svelte-1d26vpt:not(:first-child):hover{background:#e6e6e6}th.svelte-1d26vpt{text-align:left}td.svelte-1d26vpt{vertical-align:middle;padding-top:4px;padding-bottom:4px;width:1%}.sir-table td input,.sir-table td select,.sir-table td button{margin:0px !important;width:auto}.editButtons.svelte-1d26vpt{text-align:right}.sir-table .editButtons div,.sir-table th div{display:inline-block}.sir-table td .checkbox{display:table-cell}.sir-table td .sir-input{display:block}");
}

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[55] = list[i];
	child_ctx[57] = i;
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[58] = list[i];
	child_ctx[59] = list;
	child_ctx[60] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[61] = list[i];
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[64] = list[i];
	child_ctx[65] = list;
	child_ctx[60] = i;
	return child_ctx;
}

// (216:10) {:else}
function create_else_block_4(ctx) {
	let t0_value = (/*h*/ ctx[64].name ? /*h*/ ctx[64].name : /*h*/ ctx[64]) + "";
	let t0;
	let t1;
	let if_block_anchor;
	let current;
	let if_block = /*editTable*/ ctx[5] && /*editColumns*/ ctx[4] && create_if_block_14(ctx);

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 2) && t0_value !== (t0_value = (/*h*/ ctx[64].name ? /*h*/ ctx[64].name : /*h*/ ctx[64]) + "")) set_data(t0, t0_value);

			if (/*editTable*/ ctx[5] && /*editColumns*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*editTable, editColumns*/ 48) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_14(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (210:10) {#if edit.type === "column"}
function create_if_block_12(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_13, create_else_block_3];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*h*/ ctx[64]?.name) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (218:12) {#if editTable && editColumns}
function create_if_block_14(ctx) {
	let button;
	let current;

	function click_handler() {
		return /*click_handler*/ ctx[38](/*hIndex*/ ctx[60]);
	}

	button = new Button({
			props: {
				small: true,
				inline: true,
				icon: "trash",
				disabled: /*edit*/ ctx[6].type
			}
		});

	button.$on("click", click_handler);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};
			if (dirty[0] & /*edit*/ 64) button_changes.disabled = /*edit*/ ctx[6].type;
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (213:12) {:else}
function create_else_block_3(ctx) {
	let input;
	let updating_value;
	let current;

	function input_value_binding_1(value) {
		/*input_value_binding_1*/ ctx[37](value, /*h*/ ctx[64], /*each_value_3*/ ctx[65], /*hIndex*/ ctx[60]);
	}

	let input_props = { inline: true };

	if (/*h*/ ctx[64] !== void 0) {
		input_props.value = /*h*/ ctx[64];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'value', input_value_binding_1));

	return {
		c() {
			create_component(input.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const input_changes = {};

			if (!updating_value && dirty[0] & /*header*/ 2) {
				updating_value = true;
				input_changes.value = /*h*/ ctx[64];
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
		}
	};
}

// (211:12) {#if h?.name}
function create_if_block_13(ctx) {
	let input;
	let updating_value;
	let current;

	function input_value_binding(value) {
		/*input_value_binding*/ ctx[36](value, /*h*/ ctx[64]);
	}

	let input_props = { inline: true };

	if (/*h*/ ctx[64].name !== void 0) {
		input_props.value = /*h*/ ctx[64].name;
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'value', input_value_binding));

	return {
		c() {
			create_component(input.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const input_changes = {};

			if (!updating_value && dirty[0] & /*header*/ 2) {
				updating_value = true;
				input_changes.value = /*h*/ ctx[64].name;
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
		}
	};
}

// (208:6) {#each header as h, hIndex}
function create_each_block_3(ctx) {
	let th;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block_12, create_else_block_4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*edit*/ ctx[6].type === "column") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			th = element("th");
			if_block.c();
			attr(th, "class", "svelte-1d26vpt");
		},
		m(target, anchor) {
			insert(target, th, anchor);
			if_blocks[current_block_type_index].m(th, null);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(th, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(th);
			if_blocks[current_block_type_index].d();
		}
	};
}

// (229:26) 
function create_if_block_10(ctx) {
	let th;
	let current;
	let if_block = /*editColumns*/ ctx[4] && create_if_block_11(ctx);

	return {
		c() {
			th = element("th");
			if (if_block) if_block.c();
			attr(th, "class", "editButtons svelte-1d26vpt");
		},
		m(target, anchor) {
			insert(target, th, anchor);
			if (if_block) if_block.m(th, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*editColumns*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*editColumns*/ 16) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_11(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(th, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(th);
			if (if_block) if_block.d();
		}
	};
}

// (224:6) {#if edit.type === "column"}
function create_if_block_9(ctx) {
	let th;
	let button0;
	let t;
	let button1;
	let current;

	button0 = new Button({
			props: {
				small: true,
				inline: true,
				icon: "close",
				disabled: /*edit*/ ctx[6].type === "row"
			}
		});

	button0.$on("click", /*undoColChange*/ ctx[11]);

	button1 = new Button({
			props: {
				small: true,
				inline: true,
				icon: "check",
				disabled: /*edit*/ ctx[6].type === "row"
			}
		});

	button1.$on("click", /*doColumnRowEdit*/ ctx[12]);

	return {
		c() {
			th = element("th");
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
			attr(th, "class", "editButtons svelte-1d26vpt");
		},
		m(target, anchor) {
			insert(target, th, anchor);
			mount_component(button0, th, null);
			append(th, t);
			mount_component(button1, th, null);
			current = true;
		},
		p(ctx, dirty) {
			const button0_changes = {};
			if (dirty[0] & /*edit*/ 64) button0_changes.disabled = /*edit*/ ctx[6].type === "row";
			button0.$set(button0_changes);
			const button1_changes = {};
			if (dirty[0] & /*edit*/ 64) button1_changes.disabled = /*edit*/ ctx[6].type === "row";
			button1.$set(button1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(th);
			destroy_component(button0);
			destroy_component(button1);
		}
	};
}

// (231:10) {#if editColumns}
function create_if_block_11(ctx) {
	let button0;
	let t;
	let button1;
	let current;

	button0 = new Button({
			props: {
				small: true,
				inline: true,
				icon: "plus",
				disabled: /*edit*/ ctx[6].type === "row"
			}
		});

	button0.$on("click", /*addCol*/ ctx[17]);

	button1 = new Button({
			props: {
				small: true,
				inline: true,
				icon: "edit",
				disabled: /*edit*/ ctx[6].type === "row"
			}
		});

	button1.$on("click", /*click_handler_1*/ ctx[39]);

	return {
		c() {
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button0, target, anchor);
			insert(target, t, anchor);
			mount_component(button1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button0_changes = {};
			if (dirty[0] & /*edit*/ 64) button0_changes.disabled = /*edit*/ ctx[6].type === "row";
			button0.$set(button0_changes);
			const button1_changes = {};
			if (dirty[0] & /*edit*/ 64) button1_changes.disabled = /*edit*/ ctx[6].type === "row";
			button1.$set(button1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button0, detaching);
			if (detaching) detach(t);
			destroy_component(button1, detaching);
		}
	};
}

// (257:14) {:else}
function create_else_block_2$1(ctx) {
	let t_value = /*colValue*/ ctx[58] + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rows*/ 4 && t_value !== (t_value = /*colValue*/ ctx[58] + "")) set_data(t, t_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (255:14) {#if header?.[hIndex]?.type === "checkbox"}
function create_if_block_8(ctx) {
	let input;
	let updating_value;
	let current;

	function input_value_binding_3(value) {
		/*input_value_binding_3*/ ctx[42](value, /*colValue*/ ctx[58], /*each_value_1*/ ctx[59], /*hIndex*/ ctx[60]);
	}

	let input_props = {
		id: `${/*id*/ ctx[0]}-pos-${/*rowIndex*/ ctx[57]}/${/*hIndex*/ ctx[60]}-input`,
		inline: true,
		type: "checkbox",
		disabled: true
	};

	if (/*colValue*/ ctx[58] !== void 0) {
		input_props.value = /*colValue*/ ctx[58];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'value', input_value_binding_3));

	return {
		c() {
			create_component(input.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const input_changes = {};
			if (dirty[0] & /*id*/ 1) input_changes.id = `${/*id*/ ctx[0]}-pos-${/*rowIndex*/ ctx[57]}/${/*hIndex*/ ctx[60]}-input`;

			if (!updating_value && dirty[0] & /*rows*/ 4) {
				updating_value = true;
				input_changes.value = /*colValue*/ ctx[58];
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
		}
	};
}

// (242:12) {#if edit.index === rowIndex}
function create_if_block_4(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_5, create_if_block_6, create_if_block_7];
	const if_blocks = [];

	function select_block_type_4(ctx, dirty) {
		if (/*header*/ ctx[1][/*hIndex*/ ctx[60]].edit !== false && /*header*/ ctx[1][/*hIndex*/ ctx[60]].type !== "select") return 0;
		if (/*header*/ ctx[1]?.[/*hIndex*/ ctx[60]]?.edit === false) return 1;
		if (/*header*/ ctx[1][/*hIndex*/ ctx[60]].type === "select") return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_4(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_4(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

// (247:57) 
function create_if_block_7(ctx) {
	let select;
	let updating_value;
	let current;

	function select_value_binding(value) {
		/*select_value_binding*/ ctx[41](value, /*colValue*/ ctx[58], /*each_value_1*/ ctx[59], /*hIndex*/ ctx[60]);
	}

	let select_props = {
		id: `${/*id*/ ctx[0]}-pos-${/*rowIndex*/ ctx[57]}/${/*hIndex*/ ctx[60]}-input`,
		inline: true,
		$$slots: { default: [create_default_slot_5$1] },
		$$scope: { ctx }
	};

	if (/*colValue*/ ctx[58] !== void 0) {
		select_props.value = /*colValue*/ ctx[58];
	}

	select = new Select({ props: select_props });
	binding_callbacks.push(() => bind(select, 'value', select_value_binding));

	return {
		c() {
			create_component(select.$$.fragment);
		},
		m(target, anchor) {
			mount_component(select, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const select_changes = {};
			if (dirty[0] & /*id*/ 1) select_changes.id = `${/*id*/ ctx[0]}-pos-${/*rowIndex*/ ctx[57]}/${/*hIndex*/ ctx[60]}-input`;

			if (dirty[0] & /*header*/ 2 | dirty[2] & /*$$scope*/ 16) {
				select_changes.$$scope = { dirty, ctx };
			}

			if (!updating_value && dirty[0] & /*rows*/ 4) {
				updating_value = true;
				select_changes.value = /*colValue*/ ctx[58];
				add_flush_callback(() => updating_value = false);
			}

			select.$set(select_changes);
		},
		i(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(select.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(select, detaching);
		}
	};
}

// (245:57) 
function create_if_block_6(ctx) {
	let t_value = /*colValue*/ ctx[58] + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rows*/ 4 && t_value !== (t_value = /*colValue*/ ctx[58] + "")) set_data(t, t_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (243:14) {#if header[hIndex].edit !== false && header[hIndex].type !== "select" }
function create_if_block_5(ctx) {
	let input;
	let updating_value;
	let current;

	function input_value_binding_2(value) {
		/*input_value_binding_2*/ ctx[40](value, /*colValue*/ ctx[58], /*each_value_1*/ ctx[59], /*hIndex*/ ctx[60]);
	}

	let input_props = {
		id: `${/*id*/ ctx[0]}-pos-${/*rowIndex*/ ctx[57]}/${/*hIndex*/ ctx[60]}-input`,
		inline: true,
		type: (/*header*/ ctx[1]?.[/*hIndex*/ ctx[60]]?.type)
		? /*header*/ ctx[1]?.[/*hIndex*/ ctx[60]]?.type
		: "text"
	};

	if (/*colValue*/ ctx[58] !== void 0) {
		input_props.value = /*colValue*/ ctx[58];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'value', input_value_binding_2));

	return {
		c() {
			create_component(input.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const input_changes = {};
			if (dirty[0] & /*id*/ 1) input_changes.id = `${/*id*/ ctx[0]}-pos-${/*rowIndex*/ ctx[57]}/${/*hIndex*/ ctx[60]}-input`;

			if (dirty[0] & /*header*/ 2) input_changes.type = (/*header*/ ctx[1]?.[/*hIndex*/ ctx[60]]?.type)
			? /*header*/ ctx[1]?.[/*hIndex*/ ctx[60]]?.type
			: "text";

			if (!updating_value && dirty[0] & /*rows*/ 4) {
				updating_value = true;
				input_changes.value = /*colValue*/ ctx[58];
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
		}
	};
}

// (249:18) {#each header[hIndex].options as option}
function create_each_block_2(ctx) {
	let option;
	let t_value = /*option*/ ctx[61].name + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*option*/ ctx[61].value;
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*header*/ 2 && t_value !== (t_value = /*option*/ ctx[61].name + "")) set_data(t, t_value);

			if (dirty[0] & /*header*/ 2 && option_value_value !== (option_value_value = /*option*/ ctx[61].value)) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (248:16) <Select id={`${id}-pos-${rowIndex}/${hIndex}-input`} inline bind:value={colValue}>
function create_default_slot_5$1(ctx) {
	let each_1_anchor;
	let each_value_2 = /*header*/ ctx[1][/*hIndex*/ ctx[60]].options;
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*header*/ 2) {
				each_value_2 = /*header*/ ctx[1][/*hIndex*/ ctx[60]].options;
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (240:8) {#each row as colValue, hIndex}
function create_each_block_1$1(ctx) {
	let td;
	let current_block_type_index;
	let if_block;
	let td_id_value;
	let current;
	const if_block_creators = [create_if_block_4, create_if_block_8, create_else_block_2$1];
	const if_blocks = [];

	function select_block_type_3(ctx, dirty) {
		if (/*edit*/ ctx[6].index === /*rowIndex*/ ctx[57]) return 0;
		if (/*header*/ ctx[1]?.[/*hIndex*/ ctx[60]]?.type === "checkbox") return 1;
		return 2;
	}

	current_block_type_index = select_block_type_3(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			td = element("td");
			if_block.c();
			attr(td, "id", td_id_value = `${/*id*/ ctx[0]}-pos-${/*rowIndex*/ ctx[57]}/${/*hIndex*/ ctx[60]}`);
			attr(td, "class", "svelte-1d26vpt");
		},
		m(target, anchor) {
			insert(target, td, anchor);
			if_blocks[current_block_type_index].m(td, null);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_3(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(td, null);
			}

			if (!current || dirty[0] & /*id*/ 1 && td_id_value !== (td_id_value = `${/*id*/ ctx[0]}-pos-${/*rowIndex*/ ctx[57]}/${/*hIndex*/ ctx[60]}`)) {
				attr(td, "id", td_id_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(td);
			if_blocks[current_block_type_index].d();
		}
	};
}

// (263:8) {#if editTable}
function create_if_block_2$1(ctx) {
	let td;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block_3$1, create_else_block_1$1];
	const if_blocks = [];

	function select_block_type_5(ctx, dirty) {
		if (/*edit*/ ctx[6].index === /*rowIndex*/ ctx[57]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_5(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			td = element("td");
			if_block.c();
			attr(td, "class", "editButtons svelte-1d26vpt");
		},
		m(target, anchor) {
			insert(target, td, anchor);
			if_blocks[current_block_type_index].m(td, null);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_5(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(td, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(td);
			if_blocks[current_block_type_index].d();
		}
	};
}

// (268:10) {:else}
function create_else_block_1$1(ctx) {
	let button0;
	let t;
	let button1;
	let current;

	function click_handler_3() {
		return /*click_handler_3*/ ctx[44](/*rowIndex*/ ctx[57]);
	}

	button0 = new Button({
			props: {
				inline: true,
				small: true,
				icon: "edit",
				disabled: /*edit*/ ctx[6].type === "column" || /*edit*/ ctx[6].type === "row" && /*rowIndex*/ ctx[57] !== /*edit*/ ctx[6].index
			}
		});

	button0.$on("click", click_handler_3);

	function click_handler_4() {
		return /*click_handler_4*/ ctx[45](/*rowIndex*/ ctx[57]);
	}

	button1 = new Button({
			props: {
				inline: true,
				small: true,
				icon: "trash",
				disabled: /*edit*/ ctx[6].type === "column" || /*edit*/ ctx[6].type === "row" && /*rowIndex*/ ctx[57] !== /*edit*/ ctx[6].index
			}
		});

	button1.$on("click", click_handler_4);

	return {
		c() {
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button0, target, anchor);
			insert(target, t, anchor);
			mount_component(button1, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const button0_changes = {};
			if (dirty[0] & /*edit*/ 64) button0_changes.disabled = /*edit*/ ctx[6].type === "column" || /*edit*/ ctx[6].type === "row" && /*rowIndex*/ ctx[57] !== /*edit*/ ctx[6].index;
			button0.$set(button0_changes);
			const button1_changes = {};
			if (dirty[0] & /*edit*/ 64) button1_changes.disabled = /*edit*/ ctx[6].type === "column" || /*edit*/ ctx[6].type === "row" && /*rowIndex*/ ctx[57] !== /*edit*/ ctx[6].index;
			button1.$set(button1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button0, detaching);
			if (detaching) detach(t);
			destroy_component(button1, detaching);
		}
	};
}

// (265:10) {#if edit.index === rowIndex}
function create_if_block_3$1(ctx) {
	let button0;
	let t;
	let button1;
	let current;

	function click_handler_2() {
		return /*click_handler_2*/ ctx[43](/*rowIndex*/ ctx[57]);
	}

	button0 = new Button({
			props: { inline: true, small: true, icon: "close" }
		});

	button0.$on("click", click_handler_2);

	button1 = new Button({
			props: {
				inline: true,
				small: true,
				icon: "check",
				primary: true
			}
		});

	button1.$on("click", /*doColumnRowEdit*/ ctx[12]);

	return {
		c() {
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button0, target, anchor);
			insert(target, t, anchor);
			mount_component(button1, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button0, detaching);
			if (detaching) detach(t);
			destroy_component(button1, detaching);
		}
	};
}

// (238:4) {#each rows as row, rowIndex}
function create_each_block$1(ctx) {
	let tr;
	let t0;
	let t1;
	let tr_id_value;
	let current;
	let each_value_1 = /*row*/ ctx[55];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let if_block = /*editTable*/ ctx[5] && create_if_block_2$1(ctx);

	return {
		c() {
			tr = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			attr(tr, "id", tr_id_value = /*id*/ ctx[0] + "-pos-" + /*rowIndex*/ ctx[57]);
			attr(tr, "class", "svelte-1d26vpt");
		},
		m(target, anchor) {
			insert(target, tr, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append(tr, t0);
			if (if_block) if_block.m(tr, null);
			append(tr, t1);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*id, header, rows, edit*/ 71) {
				each_value_1 = /*row*/ ctx[55];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(tr, t0);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (/*editTable*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*editTable*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(tr, t1);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*id*/ 1 && tr_id_value !== (tr_id_value = /*id*/ ctx[0] + "-pos-" + /*rowIndex*/ ctx[57])) {
				attr(tr, "id", tr_id_value);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block);
			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(tr);
			destroy_each(each_blocks, detaching);
			if (if_block) if_block.d();
		}
	};
}

// (205:0) <Row clazz="sir-table">
function create_default_slot_4$1(ctx) {
	let table;
	let tr;
	let t0;
	let current_block_type_index;
	let if_block;
	let t1;
	let current;
	let each_value_3 = /*header*/ ctx[1];
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
		each_blocks_1[i] = null;
	});

	const if_block_creators = [create_if_block_9, create_if_block_10];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*edit*/ ctx[6].type === "column") return 0;
		if (/*editTable*/ ctx[5]) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_2(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	let each_value = /*rows*/ ctx[2];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			table = element("table");
			tr = element("tr");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t0 = space();
			if (if_block) if_block.c();
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(tr, "class", "svelte-1d26vpt");
			attr(table, "id", /*id*/ ctx[0]);
			attr(table, "class", "svelte-1d26vpt");
			toggle_class(table, "editable", /*editTable*/ ctx[5]);
			toggle_class(table, "editColumns", /*editColumns*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, table, anchor);
			append(table, tr);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(tr, null);
			}

			append(tr, t0);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(tr, null);
			}

			append(table, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(table, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*header, edit, prepDelete, editTable, editColumns*/ 262258) {
				each_value_3 = /*header*/ ctx[1];
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
						transition_in(each_blocks_1[i], 1);
					} else {
						each_blocks_1[i] = create_each_block_3(child_ctx);
						each_blocks_1[i].c();
						transition_in(each_blocks_1[i], 1);
						each_blocks_1[i].m(tr, t0);
					}
				}

				group_outros();

				for (i = each_value_3.length; i < each_blocks_1.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(tr, null);
				} else {
					if_block = null;
				}
			}

			if (dirty[0] & /*id, doColumnRowEdit, undoRowChange, edit, prepDelete, prepChange, editTable, rows, header*/ 267879) {
				each_value = /*rows*/ ctx[2];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(table, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out_1(i);
				}

				check_outros();
			}

			if (!current || dirty[0] & /*id*/ 1) {
				attr(table, "id", /*id*/ ctx[0]);
			}

			if (dirty[0] & /*editTable*/ 32) {
				toggle_class(table, "editable", /*editTable*/ ctx[5]);
			}

			if (dirty[0] & /*editColumns*/ 16) {
				toggle_class(table, "editColumns", /*editColumns*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_3.length; i += 1) {
				transition_in(each_blocks_1[i]);
			}

			transition_in(if_block);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks_1 = each_blocks_1.filter(Boolean);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				transition_out(each_blocks_1[i]);
			}

			transition_out(if_block);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(table);
			destroy_each(each_blocks_1, detaching);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (279:0) {#if editable}
function create_if_block$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type_6(ctx, dirty) {
		if (/*editTable*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_6(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_6(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (288:2) {:else}
function create_else_block$1(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				style: "display: block",
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};

			if (dirty[0] & /*id, language, edit*/ 321 | dirty[2] & /*$$scope*/ 16) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

// (280:2) {#if editTable}
function create_if_block_1$1(ctx) {
	let row0;
	let t;
	let row1;
	let current;

	row0 = new Row({
			props: {
				style: "display: block",
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			}
		});

	row1 = new Row({
			props: {
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row0.$$.fragment);
			t = space();
			create_component(row1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row0, target, anchor);
			insert(target, t, anchor);
			mount_component(row1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row0_changes = {};

			if (dirty[0] & /*id, language, edit*/ 321 | dirty[2] & /*$$scope*/ 16) {
				row0_changes.$$scope = { dirty, ctx };
			}

			row0.$set(row0_changes);
			const row1_changes = {};

			if (dirty[0] & /*id, language, edit*/ 321 | dirty[2] & /*$$scope*/ 16) {
				row1_changes.$$scope = { dirty, ctx };
			}

			row1.$set(row1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row0.$$.fragment, local);
			transition_in(row1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row0.$$.fragment, local);
			transition_out(row1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row0, detaching);
			if (detaching) detach(t);
			destroy_component(row1, detaching);
		}
	};
}

// (289:4) <Row style="display: block">
function create_default_slot_3$1(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				small: true,
				id: /*id*/ ctx[0] + '-startEdit',
				icon: "edit",
				label: /*translations*/ ctx[21][/*language*/ ctx[8]].editTable,
				disabled: /*edit*/ ctx[6].type
			}
		});

	button.$on("click", /*startEditingTable*/ ctx[13]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty[0] & /*id*/ 1) button_changes.id = /*id*/ ctx[0] + '-startEdit';
			if (dirty[0] & /*language*/ 256) button_changes.label = /*translations*/ ctx[21][/*language*/ ctx[8]].editTable;
			if (dirty[0] & /*edit*/ 64) button_changes.disabled = /*edit*/ ctx[6].type;
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (281:4) <Row style="display: block">
function create_default_slot_2$1(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				small: true,
				id: /*id*/ ctx[0] + '-addRow',
				icon: "plus",
				label: /*translations*/ ctx[21][/*language*/ ctx[8]].addRow,
				disabled: /*edit*/ ctx[6].type
			}
		});

	button.$on("click", /*addRow*/ ctx[16]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty[0] & /*id*/ 1) button_changes.id = /*id*/ ctx[0] + '-addRow';
			if (dirty[0] & /*language*/ 256) button_changes.label = /*translations*/ ctx[21][/*language*/ ctx[8]].addRow;
			if (dirty[0] & /*edit*/ 64) button_changes.disabled = /*edit*/ ctx[6].type;
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (284:4) <Row>
function create_default_slot_1$1(ctx) {
	let button0;
	let t;
	let button1;
	let current;

	button0 = new Button({
			props: {
				small: true,
				id: /*id*/ ctx[0] + '-cancelEdit',
				icon: "close",
				label: /*translations*/ ctx[21][/*language*/ ctx[8]].cancel,
				disabled: /*edit*/ ctx[6].type
			}
		});

	button0.$on("click", /*cancelEditingTable*/ ctx[15]);

	button1 = new Button({
			props: {
				small: true,
				id: /*id*/ ctx[0] + '-endEdit',
				icon: "check",
				label: /*translations*/ ctx[21][/*language*/ ctx[8]].endEdit,
				primary: true,
				disabled: /*edit*/ ctx[6].type
			}
		});

	button1.$on("click", /*endEditingTable*/ ctx[14]);

	return {
		c() {
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button0, target, anchor);
			insert(target, t, anchor);
			mount_component(button1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button0_changes = {};
			if (dirty[0] & /*id*/ 1) button0_changes.id = /*id*/ ctx[0] + '-cancelEdit';
			if (dirty[0] & /*language*/ 256) button0_changes.label = /*translations*/ ctx[21][/*language*/ ctx[8]].cancel;
			if (dirty[0] & /*edit*/ 64) button0_changes.disabled = /*edit*/ ctx[6].type;
			button0.$set(button0_changes);
			const button1_changes = {};
			if (dirty[0] & /*id*/ 1) button1_changes.id = /*id*/ ctx[0] + '-endEdit';
			if (dirty[0] & /*language*/ 256) button1_changes.label = /*translations*/ ctx[21][/*language*/ ctx[8]].endEdit;
			if (dirty[0] & /*edit*/ 64) button1_changes.disabled = /*edit*/ ctx[6].type;
			button1.$set(button1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button0, detaching);
			if (detaching) detach(t);
			destroy_component(button1, detaching);
		}
	};
}

// (296:0) <Popup id="askDeleteTable" bind:showPopup={deleteOptions.showPopup} modal={true} fixed={true} type="warning" keyboard={keysDeletePopup}>
function create_default_slot$1(ctx) {
	let h2;
	let t0_value = /*translations*/ ctx[21][/*language*/ ctx[8]].confirmDelete + "";
	let t0;
	let t1;
	let div;
	let t2_value = /*deleteOptions*/ ctx[7].text + "";
	let t2;

	return {
		c() {
			h2 = element("h2");
			t0 = text(t0_value);
			t1 = space();
			div = element("div");
			t2 = text(t2_value);
		},
		m(target, anchor) {
			insert(target, h2, anchor);
			append(h2, t0);
			insert(target, t1, anchor);
			insert(target, div, anchor);
			append(div, t2);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*language*/ 256 && t0_value !== (t0_value = /*translations*/ ctx[21][/*language*/ ctx[8]].confirmDelete + "")) set_data(t0, t0_value);
			if (dirty[0] & /*deleteOptions*/ 128 && t2_value !== (t2_value = /*deleteOptions*/ ctx[7].text + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(h2);
			if (detaching) detach(t1);
			if (detaching) detach(div);
		}
	};
}

// (299:2) 
function create_buttons_slot$1(ctx) {
	let span;
	let button0;
	let t;
	let button1;
	let current;
	button0 = new Button({ props: { label: "Okay", primary: true } });
	button0.$on("click", /*handleDelete*/ ctx[19]);

	button1 = new Button({
			props: {
				label: /*deleteOptions*/ ctx[7].cancelButton
			}
		});

	button1.$on("click", /*click_handler_5*/ ctx[46]);

	return {
		c() {
			span = element("span");
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
			attr(span, "slot", "buttons");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			mount_component(button0, span, null);
			append(span, t);
			mount_component(button1, span, null);
			current = true;
		},
		p(ctx, dirty) {
			const button1_changes = {};
			if (dirty[0] & /*deleteOptions*/ 128) button1_changes.label = /*deleteOptions*/ ctx[7].cancelButton;
			button1.$set(button1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			destroy_component(button0);
			destroy_component(button1);
		}
	};
}

function create_fragment$1(ctx) {
	let row;
	let t0;
	let t1;
	let popup;
	let updating_showPopup;
	let current;

	row = new Row({
			props: {
				clazz: "sir-table",
				$$slots: { default: [create_default_slot_4$1] },
				$$scope: { ctx }
			}
		});

	let if_block = /*editable*/ ctx[3] && create_if_block$1(ctx);

	function popup_showPopup_binding(value) {
		/*popup_showPopup_binding*/ ctx[47](value);
	}

	let popup_props = {
		id: "askDeleteTable",
		modal: true,
		fixed: true,
		type: "warning",
		keyboard: /*keysDeletePopup*/ ctx[20],
		$$slots: {
			buttons: [create_buttons_slot$1],
			default: [create_default_slot$1]
		},
		$$scope: { ctx }
	};

	if (/*deleteOptions*/ ctx[7].showPopup !== void 0) {
		popup_props.showPopup = /*deleteOptions*/ ctx[7].showPopup;
	}

	popup = new Popup({ props: popup_props });
	binding_callbacks.push(() => bind(popup, 'showPopup', popup_showPopup_binding));

	return {
		c() {
			create_component(row.$$.fragment);
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			create_component(popup.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			insert(target, t0, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, t1, anchor);
			mount_component(popup, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};

			if (dirty[0] & /*id, editTable, editColumns, rows, edit, header*/ 119 | dirty[2] & /*$$scope*/ 16) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);

			if (/*editable*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*editable*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t1.parentNode, t1);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const popup_changes = {};

			if (dirty[0] & /*deleteOptions, language*/ 384 | dirty[2] & /*$$scope*/ 16) {
				popup_changes.$$scope = { dirty, ctx };
			}

			if (!updating_showPopup && dirty[0] & /*deleteOptions*/ 128) {
				updating_showPopup = true;
				popup_changes.showPopup = /*deleteOptions*/ ctx[7].showPopup;
				add_flush_callback(() => updating_showPopup = false);
			}

			popup.$set(popup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			transition_in(if_block);
			transition_in(popup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			transition_out(if_block);
			transition_out(popup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
			if (detaching) detach(t0);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t1);
			destroy_component(popup, detaching);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { node, prop, value, header, rows, id, editable = false, editColumns = true, i18n, beforeEditTable, afterEditTable, afterCancelEditTable, afterEditColumns, afterEditRow, beforeAddRow, afterAddRow, afterAddColumn, afterDelete } = $$props;

	if (!id) {
		id = getId(prop);
	}

	editable = getBooleanFrom(editable);
	editColumns = getBooleanFrom(editColumns);
	let editTable = false;
	let edit = {};
	let defaults = {};
	let oldColRow = [];
	let oldTable = [];
	let isNew = false;
	let deleteOptions = {};

	if (node) {
		defaults = node._def.defaults;
	}

	const dispatch = createEventDispatcher();
	const updateNode = typeof node !== 'undefined';
	value = updateNode && node[prop] || value || null;
	header = header || value?.header || defaults?.[prop]?.value?.header || [];
	rows = rows || value?.rows || defaults?.[prop]?.value?.rows || [];
	let init = true;

	header.forEach((h, i) => {
		$$invalidate(1, header[i] = i18nTranslate(RED, node, i18n, h), header);
	});

	const prepChange = (i, type) => {
		$$invalidate(6, edit.type = type, edit);

		if (type === 'row') {
			$$invalidate(6, edit.index = i, edit);
			oldColRow = [...rows[i]];
		} else if (type === 'column') {
			oldColRow = [...header];
		}
	};

	const undoRowChange = i => {
		if (isNew) {
			rows.pop();
		} else {
			$$invalidate(2, rows[i] = [...oldColRow], rows);
		}

		endRowColumnEdit();
	};

	const undoColChange = () => {
		if (isNew) {
			header.pop();
			rows.forEach((row, i) => rows[i].pop());
			$$invalidate(2, rows);
		} else {
			$$invalidate(1, header = [...oldColRow]);
		}

		endRowColumnEdit();
	};

	const doColumnRowEdit = () => {
		if (edit.type === 'column') {
			if (isNew && afterAddColumn) afterAddColumn(header, oldColRow); else if (afterEditColumns) afterEditColumns(header, oldColRow);
		} else if (edit.type === 'row') {
			if (isNew && afterAddRow) afterAddRow(rows[edit.index], edit.index, oldColRow); else if (afterEditRow) afterEditRow(rows[edit.index], edit.index, oldColRow);
		}

		endRowColumnEdit();
	};

	const endRowColumnEdit = () => {
		oldColRow = [];
		$$invalidate(6, edit = {});
		isNew = false;
	};

	const startEditingTable = () => {
		$$invalidate(5, editTable = true);
		oldTable = { header: [...header], rows: [...rows] };

		if (beforeEditTable) {
			beforeEditTable(header, rows);
		}
	};

	const endEditingTable = () => {
		$$invalidate(5, editTable = false);

		if (afterEditTable) {
			afterEditTable(header, rows);
		}

		oldTable = [];
	};

	const cancelEditingTable = () => {
		$$invalidate(5, editTable = false);
		$$invalidate(1, header = [...oldTable.header]);
		$$invalidate(2, rows = [...oldTable.rows]);
		oldTable = [];

		if (afterCancelEditTable) {
			afterCancelEditTable(header, rows);
		}
	};

	const addRow = () => {
		const newRow = new Array(header.length).fill('');
		rows.push(newRow);
		const index = rows.length - 1;
		prepChange(index, 'row');
		isNew = true;

		if (beforeAddRow) {
			beforeAddRow(rows[index], index);
		}
	};

	const addCol = () => {
		prepChange(null, 'column');
		isNew = true;
		header.push('');
		rows.forEach((row, i) => rows[i].push(''));
	};

	const prepDelete = (i, type) => {
		$$invalidate(7, deleteOptions.type = type, deleteOptions);
		$$invalidate(7, deleteOptions.index = i, deleteOptions);
		$$invalidate(7, deleteOptions.text = `${translations[language].delete} ${translations[language][type]} ${i + 1}?`, deleteOptions);
		$$invalidate(7, deleteOptions.showPopup = true, deleteOptions);
		$$invalidate(7, deleteOptions.cancelButton = translations[language].cancel, deleteOptions);
	};

	const handleDelete = () => {
		const deletedRow = [...rows[deleteOptions.index]];

		if (deleteOptions.type === 'row') {
			$$invalidate(2, rows = rows.filter((el, i) => i !== deleteOptions.index));
		} else if (deleteOptions.type === 'column') {
			$$invalidate(1, header = header.filter((el, i) => i !== deleteOptions.index));

			rows.forEach((row, i) => {
				$$invalidate(2, rows[i] = row.filter((el, column) => column !== deleteOptions.index), rows);
			});
		}

		if (value) {
			$$invalidate(22, value.header = header, value);
			$$invalidate(22, value.rows = rows, value);
		}

		closePopup('askDeleteTable');
		if (afterDelete) afterDelete(deleteOptions.type, deleteOptions.index, deletedRow);
	};

	const keysDeletePopup = {
		escape: () => closePopup('askDeleteTable'),
		enter: () => handleDelete()
	};

	const translations = {
		'en-US': {
			addRow: 'Add row',
			confirmDelete: 'Please confirm delete!',
			delete: 'Delete',
			row: "row",
			column: "column",
			editTable: 'Edit table',
			endEdit: 'Okay',
			cancel: 'Cancel'
		},
		de: {
			addRow: 'Hinzufügen',
			confirmDelete: 'Bitte Löschen bestätigen!',
			delete: 'Lösche',
			row: "Reihe",
			column: "Spalte",
			editTable: 'Tabelle bearbeiten',
			endEdit: 'Bestätigen',
			cancel: 'Abruch'
		}
	};

	let language = preferredLanguage.toString();
	if (language === 'de-DE') language = 'de';
	if (!translations[language]) language = 'en-US';

	function input_value_binding(value, h) {
		if ($$self.$$.not_equal(h.name, value)) {
			h.name = value;
			$$invalidate(1, header);
		}
	}

	function input_value_binding_1(value, h, each_value_3, hIndex) {
		each_value_3[hIndex] = value;
		$$invalidate(1, header);
	}

	const click_handler = hIndex => prepDelete(hIndex, "column");
	const click_handler_1 = () => prepChange(null, "column");

	function input_value_binding_2(value, colValue, each_value_1, hIndex) {
		each_value_1[hIndex] = value;
		$$invalidate(2, rows);
	}

	function select_value_binding(value, colValue, each_value_1, hIndex) {
		each_value_1[hIndex] = value;
		$$invalidate(2, rows);
	}

	function input_value_binding_3(value, colValue, each_value_1, hIndex) {
		each_value_1[hIndex] = value;
		$$invalidate(2, rows);
	}

	const click_handler_2 = rowIndex => undoRowChange(rowIndex);
	const click_handler_3 = rowIndex => prepChange(rowIndex, "row");
	const click_handler_4 = rowIndex => prepDelete(rowIndex, "row");
	const click_handler_5 = () => closePopup("askDeleteTable");

	function popup_showPopup_binding(value) {
		if ($$self.$$.not_equal(deleteOptions.showPopup, value)) {
			deleteOptions.showPopup = value;
			$$invalidate(7, deleteOptions);
		}
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(23, node = $$props.node);
		if ('prop' in $$props) $$invalidate(24, prop = $$props.prop);
		if ('value' in $$props) $$invalidate(22, value = $$props.value);
		if ('header' in $$props) $$invalidate(1, header = $$props.header);
		if ('rows' in $$props) $$invalidate(2, rows = $$props.rows);
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('editable' in $$props) $$invalidate(3, editable = $$props.editable);
		if ('editColumns' in $$props) $$invalidate(4, editColumns = $$props.editColumns);
		if ('i18n' in $$props) $$invalidate(25, i18n = $$props.i18n);
		if ('beforeEditTable' in $$props) $$invalidate(26, beforeEditTable = $$props.beforeEditTable);
		if ('afterEditTable' in $$props) $$invalidate(27, afterEditTable = $$props.afterEditTable);
		if ('afterCancelEditTable' in $$props) $$invalidate(28, afterCancelEditTable = $$props.afterCancelEditTable);
		if ('afterEditColumns' in $$props) $$invalidate(29, afterEditColumns = $$props.afterEditColumns);
		if ('afterEditRow' in $$props) $$invalidate(30, afterEditRow = $$props.afterEditRow);
		if ('beforeAddRow' in $$props) $$invalidate(31, beforeAddRow = $$props.beforeAddRow);
		if ('afterAddRow' in $$props) $$invalidate(32, afterAddRow = $$props.afterAddRow);
		if ('afterAddColumn' in $$props) $$invalidate(33, afterAddColumn = $$props.afterAddColumn);
		if ('afterDelete' in $$props) $$invalidate(34, afterDelete = $$props.afterDelete);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*prop, value, id*/ 20971521 | $$self.$$.dirty[1] & /*init*/ 16) {
			{
				if (updateNode) {
					$$invalidate(23, node[prop] = value, node);
				}

				if (!init) {
					dispatch('change', { id, value });
				}

				$$invalidate(35, init = false);
			}
		}
	};

	return [
		id,
		header,
		rows,
		editable,
		editColumns,
		editTable,
		edit,
		deleteOptions,
		language,
		prepChange,
		undoRowChange,
		undoColChange,
		doColumnRowEdit,
		startEditingTable,
		endEditingTable,
		cancelEditingTable,
		addRow,
		addCol,
		prepDelete,
		handleDelete,
		keysDeletePopup,
		translations,
		value,
		node,
		prop,
		i18n,
		beforeEditTable,
		afterEditTable,
		afterCancelEditTable,
		afterEditColumns,
		afterEditRow,
		beforeAddRow,
		afterAddRow,
		afterAddColumn,
		afterDelete,
		init,
		input_value_binding,
		input_value_binding_1,
		click_handler,
		click_handler_1,
		input_value_binding_2,
		select_value_binding,
		input_value_binding_3,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		popup_showPopup_binding
	];
}

class Table extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$1,
			create_fragment$1,
			safe_not_equal,
			{
				node: 23,
				prop: 24,
				value: 22,
				header: 1,
				rows: 2,
				id: 0,
				editable: 3,
				editColumns: 4,
				i18n: 25,
				beforeEditTable: 26,
				afterEditTable: 27,
				afterCancelEditTable: 28,
				afterEditColumns: 29,
				afterEditRow: 30,
				beforeAddRow: 31,
				afterAddRow: 32,
				afterAddColumn: 33,
				afterDelete: 34
			},
			add_css$1,
			[-1, -1, -1]
		);
	}
}

const setError$1 = (e, doThrow) => {
  let errorMsg = e;
  if (e.message) errorMsg = e.message;
  else if (e.responseText) errorMsg = e.responseText;
  console.log('Error', errorMsg, e);
  RED.notify(errorMsg, { type: 'error', modal: true, timeout: 60000 });
  if (doThrow) throw new Error(errorMsg)
};

var error$1 = {
  setError: setError$1
};

const { setError } = error$1;

const getDefaultTable = () => {
  return {
    edit: false,
    editTableName: false,
    name: '',
    oldName: '',
    isNameUnique: true,
    isNew: false,
    header: [
      { name: 'id', edit: false }, 
      { name: 'Name', type: 'text' },
      { 
        name: 'Type',
        type: 'select',
        options: [
          { value: 'TEXT', name: 'TEXT' },
          { value: 'INTEGER', name: 'INTEGER' },
          { value: 'BLOB', name: 'BLOB' },
          { value: 'REAL', name: 'REAL' },
          { value: 'NUMERIC', name: 'NUMERIC' },
        ],
      },
      { name: 'Not null', type: 'checkbox'},
      { name: 'Primary key', type: 'checkbox'},
      { name: 'Autoincr.', type: 'checkbox'},
      { name: 'Unique', type: 'checkbox'}
    ],
    rows: [],
    disableCreation: true,
    hasAutoincrement: false
  }
};


const getIndexes = (header) => {
  i = {
    name: header.findIndex(h => h.name === 'Name'),
    type: header.findIndex(h => h.name === 'Type' ),
    notnull: header.findIndex(h => h.name === 'Not null' ),
    pk: header.findIndex(h => h.name === 'Primary key' ),
    ai: header.findIndex(h => h.name === 'Autoincr.' ),
    unique: header.findIndex(h => h.name === 'Unique' )
  };
  return i
};

const createFieldSql = (row, indexes) => {
    let fieldSql = '';
    fieldSql += `"${row[indexes.name]}" ${row[indexes.type]}`;
    if (row[indexes.notnull]) fieldSql += ' NOT NULL';
    if (row[indexes.unique]) fieldSql += ' UNIQUE';
  return fieldSql
};

const createPrimaryFieldSql = (row, indexes, primaryKey='') => {
  if (row[indexes.pk]) {
    if (!primaryKey) {
      primaryKey = ', PRIMARY KEY("' + row[indexes.name] + '"';
    } else {
      if (primaryKey.endsWith(')')) primaryKey = primaryKey.substring(0, primaryKey.length - 1);
      primaryKey += ',' + row[indexes.name];
    }
    if (row[indexes.ai]) primaryKey += ' AUTOINCREMENT';
    primaryKey += ')';
    return primaryKey
  }
  return ''
};

const createFieldsSql = (table) => {
  const header = table.header;
  const rows = table.rows;
  let fieldDef = '';
  let primaryKey = '';
  const indexes = getIndexes(header);
  rows.forEach(row => {
    if (fieldDef) fieldDef += ', ';
    fieldDef += createFieldSql(row, indexes);
    primaryKey += createPrimaryFieldSql(row, indexes, primaryKey);
  });
  return '(' + fieldDef + ' ' + primaryKey + ')'
};

const createTableSql = (path, table, copyTableName) => {
  const fieldSql = createFieldsSql(table);
  if (!path) {
    error = 'Database not found!';
    setError(error);
    throw new Error(error)
  }
  if (table.oldName) {
    return `CREATE TABLE "__${table.name}_new" ${fieldSql};`
  } else {
    let name = table.name;
    if (copyTableName) name = copyTableName;
    return `CREATE TABLE "${name}" ${fieldSql};`
  }
};

// const handleAutoincrement = (table, i) => {
//   const rows = table.rows
//   const index = getIndexes(table.header)
//   // rows[i].ai = !rows[i].ai
//   table.hasAutoincrement = rows[i].ai
//   // like highlander... there can only be one (autoincr and then also only one pk)
//   if (rows[i].ai) {
//     rows.forEach((row, index) => {
//       if (index === i) {
//         row.type = 'INTEGER'
//         row.pk = true
//       } else {
//         row.ai = false
//         row.pk = false
//       }
//     })
//   }
//   return table
// }

const checkTableAndFieldName = (selected, table) => {
  const index = getIndexes(table.header);
  table.disableCreation = true;
  // check if name already in db
  table.isNameUnique = true;
  selected.database.forEach(t => {
    if (t.name.toLowerCase() === table.name.toLowerCase()) table.isNameUnique = false;
  });
  const isFieldNameEmpty = !!(table?.rows.find(f => f[index.name].trim() === ''));

  const fieldnames = table.rows.map(f => f[index.name]);
  const hasFieldNameDuplicates = fieldnames.some((val, i) => fieldnames.indexOf(val) !== i);
  if (table.name && table.isNameUnique && !isFieldNameEmpty && !hasFieldNameDuplicates) {
    table.disableCreation = false;
  }
  return table
};

const prepareNewTable = (table, newTable) => {
  table = getDefaultTable();
  table.isNew = newTable;
  table.edit = newTable;
  table.name = '';
  table.oldName = '';
  return table
};

const prepareTable = (table, selected) => {
  if (selected.table !== null) {
    table = getDefaultTable();
    table.name = selected.database[selected.table].name;
    const indexes = getIndexes(table.header);
    selected.database[selected.table].columns.forEach((col, i) => {
      const newRow = new Array(table.header.length).fill('');
      newRow[0] = i;
      for (const [key, value] of Object.entries(col)) {
        if (indexes[key]) newRow[indexes[key]] = value;
      }
      table.rows.push(newRow);
    });
  }
  return table
};

const prepareEditTableName = (table, selected) => {
  table.editTableName = !table.editTableName;
  table.name = selected.database[selected.table].name;
  table.oldName = selected.database[selected.table].name;
  return table
};

var tableHelper = {
  getDefaultTable,
  getIndexes,
  createFieldsSql,
  createFieldSql,
  createPrimaryFieldSql,
  createTableSql,
  checkTableAndFieldName,
  prepareNewTable,
  prepareTable,
  prepareEditTableName
};

/* global RED */
const edit = (sqliteConfigNodes, selected) => {
  const db = sqliteConfigNodes.find(database => database.id === selected.databaseId);
  RED.editor.editConfig('', db.type, db.id);
  getNodes(sqliteConfigNodes);
  return sqliteConfigNodes
};

const add = (sqliteConfigNodes) => {
  try {
    RED.editor.editConfig('', 'sqlitedb', '_ADD_');
  } catch (e) {
    throw new Error('node-red-node-sqlite is not installed!')
  }
  getNodes(sqliteConfigNodes);
  return sqliteConfigNodes
};

const getNodes = (sqliteConfigNodes) => {
  sqliteConfigNodes = [];
  RED.nodes.eachConfig(function (cn) {
    // TODO if working. check memory db
    if (cn.type === 'sqlitedb' && cn.db !== ':memory:') {
      sqliteConfigNodes.push(cn);
    }
  });
  return sqliteConfigNodes
};

var sqliteConfig = {
  edit,
  add,
  getNodes
};

const clearDbStructure = (selected) => {
  selected.database = [];
  selected.path = '';
  selected.table = null;
  return selected
};

const getStructure = (selected) => {
  return new Promise((resolve, reject) => {
    if (selected.databaseId) {
      if (!selected.path) {
        reject(new Error('Database not found!'));
      }
      window.$.get('getSqliteDbStructure?path=' + selected.path)
        .success((structure) => {
          selected.database = structure;
          resolve(selected);
        }).fail((e) => {
          clearDbStructure(selected);
          reject(e);
        });
    } else {
      clearDbStructure(selected);
      resolve(selected);
    }
  })
};

var dbHelper = {
  clearDbStructure,
  getStructure
};

/* sqlite-plugin-red.svelte generated by Svelte v3.42.3 */

function add_css(target) {
	append_styles(target, "svelte-143voyw", "#sqlite-plugin-red-svelte-container{padding:20px}");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[40] = list[i].name;
	child_ctx[42] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[43] = list[i].id;
	child_ctx[44] = list[i].db;
	return child_ctx;
}

// (294:4) {#each sqliteConfigNodes as {id, db}
function create_each_block_1(ctx) {
	let option;
	let t_value = /*db*/ ctx[44] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*id*/ ctx[43];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*sqliteConfigNodes*/ 2 && t_value !== (t_value = /*db*/ ctx[44] + "")) set_data(t, t_value);

			if (dirty[0] & /*sqliteConfigNodes*/ 2 && option_value_value !== (option_value_value = /*id*/ ctx[43])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (291:2) <Select bind:value={selected.databaseId} on:change={changeDb} inline disabled={table.edit}>
function create_default_slot_5(ctx) {
	let option;
	let t1;
	let each_1_anchor;
	let each_value_1 = /*sqliteConfigNodes*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			option = element("option");
			option.textContent = "-- Select a database --";
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
			option.__value = "";
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			insert(target, t1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*sqliteConfigNodes*/ 2) {
				each_value_1 = /*sqliteConfigNodes*/ ctx[1];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
			if (detaching) detach(t1);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (290:0) <Row maximize>
function create_default_slot_4(ctx) {
	let select;
	let updating_value;
	let t0;
	let button0;
	let t1;
	let button1;
	let current;

	function select_value_binding(value) {
		/*select_value_binding*/ ctx[20](value);
	}

	let select_props = {
		inline: true,
		disabled: /*table*/ ctx[2].edit,
		$$slots: { default: [create_default_slot_5] },
		$$scope: { ctx }
	};

	if (/*selected*/ ctx[0].databaseId !== void 0) {
		select_props.value = /*selected*/ ctx[0].databaseId;
	}

	select = new Select({ props: select_props });
	binding_callbacks.push(() => bind(select, 'value', select_value_binding));
	select.$on("change", /*changeDb*/ ctx[4]);

	button0 = new Button({
			props: {
				icon: "plus",
				disabled: /*table*/ ctx[2].edit
			}
		});

	button0.$on("click", /*click_handler*/ ctx[21]);

	button1 = new Button({
			props: {
				icon: "edit",
				disabled: !/*selected*/ ctx[0].databaseId || /*table*/ ctx[2].edit
			}
		});

	button1.$on("click", /*click_handler_1*/ ctx[22]);

	return {
		c() {
			create_component(select.$$.fragment);
			t0 = space();
			create_component(button0.$$.fragment);
			t1 = space();
			create_component(button1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(select, target, anchor);
			insert(target, t0, anchor);
			mount_component(button0, target, anchor);
			insert(target, t1, anchor);
			mount_component(button1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const select_changes = {};
			if (dirty[0] & /*table*/ 4) select_changes.disabled = /*table*/ ctx[2].edit;

			if (dirty[0] & /*sqliteConfigNodes*/ 2 | dirty[1] & /*$$scope*/ 65536) {
				select_changes.$$scope = { dirty, ctx };
			}

			if (!updating_value && dirty[0] & /*selected*/ 1) {
				updating_value = true;
				select_changes.value = /*selected*/ ctx[0].databaseId;
				add_flush_callback(() => updating_value = false);
			}

			select.$set(select_changes);
			const button0_changes = {};
			if (dirty[0] & /*table*/ 4) button0_changes.disabled = /*table*/ ctx[2].edit;
			button0.$set(button0_changes);
			const button1_changes = {};
			if (dirty[0] & /*selected, table*/ 5) button1_changes.disabled = !/*selected*/ ctx[0].databaseId || /*table*/ ctx[2].edit;
			button1.$set(button1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(select.$$.fragment, local);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(select, detaching);
			if (detaching) detach(t0);
			destroy_component(button0, detaching);
			if (detaching) detach(t1);
			destroy_component(button1, detaching);
		}
	};
}

// (308:2) {:else}
function create_else_block_1(ctx) {
	let select;
	let updating_value;
	let t0;
	let current_block_type_index;
	let if_block;
	let t1;
	let button0;
	let t2;
	let button1;
	let current;

	function select_value_binding_1(value) {
		/*select_value_binding_1*/ ctx[24](value);
	}

	let select_props = {
		disabled: !/*selected*/ ctx[0].databaseId || /*table*/ ctx[2].edit,
		inline: true,
		$$slots: { default: [create_default_slot_3] },
		$$scope: { ctx }
	};

	if (/*selected*/ ctx[0].table !== void 0) {
		select_props.value = /*selected*/ ctx[0].table;
	}

	select = new Select({ props: select_props });
	binding_callbacks.push(() => bind(select, 'value', select_value_binding_1));
	select.$on("change", /*changeTable*/ ctx[5]);
	const if_block_creators = [create_if_block_3, create_else_block_2];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*table*/ ctx[2].isNew) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	button0 = new Button({
			props: {
				icon: "edit",
				disabled: /*selected*/ ctx[0].table === null || /*table*/ ctx[2].edit
			}
		});

	button0.$on("click", /*click_handler_2*/ ctx[25]);

	button1 = new Button({
			props: {
				icon: "trash",
				disabled: /*selected*/ ctx[0].table === null || /*table*/ ctx[2].edit
			}
		});

	button1.$on("click", /*click_handler_3*/ ctx[26]);

	return {
		c() {
			create_component(select.$$.fragment);
			t0 = space();
			if_block.c();
			t1 = space();
			create_component(button0.$$.fragment);
			t2 = space();
			create_component(button1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(select, target, anchor);
			insert(target, t0, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, t1, anchor);
			mount_component(button0, target, anchor);
			insert(target, t2, anchor);
			mount_component(button1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const select_changes = {};
			if (dirty[0] & /*selected, table*/ 5) select_changes.disabled = !/*selected*/ ctx[0].databaseId || /*table*/ ctx[2].edit;

			if (dirty[0] & /*selected*/ 1 | dirty[1] & /*$$scope*/ 65536) {
				select_changes.$$scope = { dirty, ctx };
			}

			if (!updating_value && dirty[0] & /*selected*/ 1) {
				updating_value = true;
				select_changes.value = /*selected*/ ctx[0].table;
				add_flush_callback(() => updating_value = false);
			}

			select.$set(select_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(t1.parentNode, t1);
			}

			const button0_changes = {};
			if (dirty[0] & /*selected, table*/ 5) button0_changes.disabled = /*selected*/ ctx[0].table === null || /*table*/ ctx[2].edit;
			button0.$set(button0_changes);
			const button1_changes = {};
			if (dirty[0] & /*selected, table*/ 5) button1_changes.disabled = /*selected*/ ctx[0].table === null || /*table*/ ctx[2].edit;
			button1.$set(button1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			transition_in(if_block);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(select.$$.fragment, local);
			transition_out(if_block);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(select, detaching);
			if (detaching) detach(t0);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(t1);
			destroy_component(button0, detaching);
			if (detaching) detach(t2);
			destroy_component(button1, detaching);
		}
	};
}

// (304:2) {#if table.editTableName}
function create_if_block_2(ctx) {
	let input;
	let updating_value;
	let t0;
	let button0;
	let t1;
	let button1;
	let current;

	function input_value_binding(value) {
		/*input_value_binding*/ ctx[23](value);
	}

	let input_props = {
		id: "sqlite-newTablename",
		placeholder: "New tablename",
		maximize: true,
		inline: true
	};

	if (/*table*/ ctx[2].name !== void 0) {
		input_props.value = /*table*/ ctx[2].name;
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'value', input_value_binding));

	button0 = new Button({
			props: {
				icon: "check",
				label: "Change name",
				disabled: /*table*/ ctx[2].name === /*table*/ ctx[2].oldName
			}
		});

	button0.$on("click", /*changeTablename*/ ctx[8]);

	button1 = new Button({
			props: { icon: "close", label: "Cancel" }
		});

	button1.$on("click", /*abortChangeTablename*/ ctx[9]);

	return {
		c() {
			create_component(input.$$.fragment);
			t0 = space();
			create_component(button0.$$.fragment);
			t1 = space();
			create_component(button1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			insert(target, t0, anchor);
			mount_component(button0, target, anchor);
			insert(target, t1, anchor);
			mount_component(button1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};

			if (!updating_value && dirty[0] & /*table*/ 4) {
				updating_value = true;
				input_changes.value = /*table*/ ctx[2].name;
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
			const button0_changes = {};
			if (dirty[0] & /*table*/ 4) button0_changes.disabled = /*table*/ ctx[2].name === /*table*/ ctx[2].oldName;
			button0.$set(button0_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach(t0);
			destroy_component(button0, detaching);
			if (detaching) detach(t1);
			destroy_component(button1, detaching);
		}
	};
}

// (311:6) {#each selected.database as {name}
function create_each_block(ctx) {
	let option;
	let t_value = /*name*/ ctx[40] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*i*/ ctx[42];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*selected*/ 1 && t_value !== (t_value = /*name*/ ctx[40] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (309:4) <Select bind:value={selected.table} disabled={!selected.databaseId || table.edit} on:change={changeTable} inline>
function create_default_slot_3(ctx) {
	let option;
	let t1;
	let each_1_anchor;
	let each_value = /*selected*/ ctx[0].database;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			option = element("option");
			option.textContent = "-- Select a table --";
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
			option.__value = null;
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			insert(target, t1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*selected*/ 1) {
				each_value = /*selected*/ ctx[0].database;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
			if (detaching) detach(t1);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (318:4) {:else}
function create_else_block_2(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				icon: "plus",
				disabled: !/*selected*/ ctx[0].databaseId || /*table*/ ctx[2].edit
			}
		});

	button.$on("click", /*addTable*/ ctx[6]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty[0] & /*selected, table*/ 5) button_changes.disabled = !/*selected*/ ctx[0].databaseId || /*table*/ ctx[2].edit;
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (316:4) {#if table.isNew}
function create_if_block_3(ctx) {
	let button;
	let current;
	button = new Button({ props: { icon: "close" } });
	button.$on("click", /*abortAddTable*/ ctx[7]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (303:0) <Row maximize>
function create_default_slot_2(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_2, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*table*/ ctx[2].editTableName) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (344:2) {:else}
function create_else_block(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.textContent = "No database / table selected.";
			attr(div, "class", "text");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (337:22) 
function create_if_block_1(ctx) {
	let input;
	let updating_value;
	let t;
	let table_1;
	let updating_value_1;
	let current;

	function input_value_binding_1(value) {
		/*input_value_binding_1*/ ctx[31](value);
	}

	let input_props = {
		id: "sqlite-newTablename",
		placeholder: "New tablename"
	};

	if (/*table*/ ctx[2].name !== void 0) {
		input_props.value = /*table*/ ctx[2].name;
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'value', input_value_binding_1));
	input.$on("change", /*change_handler*/ ctx[32]);

	function table_1_value_binding(value) {
		/*table_1_value_binding*/ ctx[33](value);
	}

	let table_1_props = {
		id: "newSqliteTable",
		maximize: true,
		editable: true,
		editColumns: false,
		afterEditTable: /*createTable*/ ctx[17],
		beforeAddRow: /*prepareNewRow*/ ctx[15],
		afterCancelEditTable: /*abortAddTable*/ ctx[7]
	};

	if (/*table*/ ctx[2] !== void 0) {
		table_1_props.value = /*table*/ ctx[2];
	}

	table_1 = new Table({ props: table_1_props });
	binding_callbacks.push(() => bind(table_1, 'value', table_1_value_binding));

	return {
		c() {
			create_component(input.$$.fragment);
			t = space();
			create_component(table_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			insert(target, t, anchor);
			mount_component(table_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};

			if (!updating_value && dirty[0] & /*table*/ 4) {
				updating_value = true;
				input_changes.value = /*table*/ ctx[2].name;
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
			const table_1_changes = {};

			if (!updating_value_1 && dirty[0] & /*table*/ 4) {
				updating_value_1 = true;
				table_1_changes.value = /*table*/ ctx[2];
				add_flush_callback(() => updating_value_1 = false);
			}

			table_1.$set(table_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(table_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(table_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach(t);
			destroy_component(table_1, detaching);
		}
	};
}

// (327:0) {#if selected.table !== null && selected.database[selected.table]}
function create_if_block(ctx) {
	let callout;
	let t;
	let table_1;
	let updating_rows;
	let current;

	callout = new Callout({
			props: {
				type: "warning",
				closeable: true,
				$$slots: {
					header: [create_header_slot],
					default: [create_default_slot_1]
				},
				$$scope: { ctx }
			}
		});

	function table_1_rows_binding(value) {
		/*table_1_rows_binding*/ ctx[30](value);
	}

	let table_1_props = {
		id: "selectedSqliteTable",
		header: /*table*/ ctx[2].header,
		maximize: true,
		editable: true,
		editColumns: false,
		beforeEditTable: /*copyTable*/ ctx[16],
		afterEditTable: /*commitChanges*/ ctx[18],
		afterCancelEditTable: /*cancelChanges*/ ctx[19],
		beforeAddRow: /*prepareNewRow*/ ctx[15],
		afterAddRow: /*func*/ ctx[27],
		afterEditRow: /*func_1*/ ctx[28],
		afterDelete: /*func_2*/ ctx[29]
	};

	if (/*table*/ ctx[2].rows !== void 0) {
		table_1_props.rows = /*table*/ ctx[2].rows;
	}

	table_1 = new Table({ props: table_1_props });
	binding_callbacks.push(() => bind(table_1, 'rows', table_1_rows_binding));

	return {
		c() {
			create_component(callout.$$.fragment);
			t = space();
			create_component(table_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callout, target, anchor);
			insert(target, t, anchor);
			mount_component(table_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const callout_changes = {};

			if (dirty[1] & /*$$scope*/ 65536) {
				callout_changes.$$scope = { dirty, ctx };
			}

			callout.$set(callout_changes);
			const table_1_changes = {};
			if (dirty[0] & /*table*/ 4) table_1_changes.header = /*table*/ ctx[2].header;

			if (!updating_rows && dirty[0] & /*table*/ 4) {
				updating_rows = true;
				table_1_changes.rows = /*table*/ ctx[2].rows;
				add_flush_callback(() => updating_rows = false);
			}

			table_1.$set(table_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			transition_in(table_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			transition_out(table_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callout, detaching);
			if (detaching) detach(t);
			destroy_component(table_1, detaching);
		}
	};
}

// (328:2) <Callout type="warning" closeable>
function create_default_slot_1(ctx) {
	let t;

	return {
		c() {
			t = text("Always backup your database before editing!");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (329:4) 
function create_header_slot(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Warning";
			attr(span, "slot", "header");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (350:0) <Popup id="askDeletePopup" modal fixed bind:showPopup={deleteOptions.showPopup} focus="sqliteConfirmDeletionName">
function create_default_slot(ctx) {
	let h2;
	let t1;
	let input;
	let updating_value;
	let t2;
	let p;
	let t3;
	let t4_value = /*deleteOptions*/ ctx[3].type + "";
	let t4;
	let t5;
	let t6_value = /*deleteOptions*/ ctx[3].name + "";
	let t6;
	let current;

	function input_value_binding_2(value) {
		/*input_value_binding_2*/ ctx[36](value);
	}

	let input_props = { id: "sqliteConfirmDeletionName" };

	if (/*deleteOptions*/ ctx[3].inputDeleteName !== void 0) {
		input_props.value = /*deleteOptions*/ ctx[3].inputDeleteName;
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'value', input_value_binding_2));

	return {
		c() {
			h2 = element("h2");
			h2.textContent = "Warning: Deleting is irreversible!";
			t1 = space();
			create_component(input.$$.fragment);
			t2 = space();
			p = element("p");
			t3 = text("To confirm enter the ");
			t4 = text(t4_value);
			t5 = text(" name: ");
			t6 = text(t6_value);
		},
		m(target, anchor) {
			insert(target, h2, anchor);
			insert(target, t1, anchor);
			mount_component(input, target, anchor);
			insert(target, t2, anchor);
			insert(target, p, anchor);
			append(p, t3);
			append(p, t4);
			append(p, t5);
			append(p, t6);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};

			if (!updating_value && dirty[0] & /*deleteOptions*/ 8) {
				updating_value = true;
				input_changes.value = /*deleteOptions*/ ctx[3].inputDeleteName;
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
			if ((!current || dirty[0] & /*deleteOptions*/ 8) && t4_value !== (t4_value = /*deleteOptions*/ ctx[3].type + "")) set_data(t4, t4_value);
			if ((!current || dirty[0] & /*deleteOptions*/ 8) && t6_value !== (t6_value = /*deleteOptions*/ ctx[3].name + "")) set_data(t6, t6_value);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h2);
			if (detaching) detach(t1);
			destroy_component(input, detaching);
			if (detaching) detach(t2);
			if (detaching) detach(p);
		}
	};
}

// (354:2) 
function create_buttons_slot(ctx) {
	let span;
	let button0;
	let t;
	let button1;
	let current;
	button0 = new Button({ props: { label: "Cancel" } });
	button0.$on("click", /*click_handler_4*/ ctx[34]);

	button1 = new Button({
			props: { label: "Delete", primary: true }
		});

	button1.$on("click", /*click_handler_5*/ ctx[35]);

	return {
		c() {
			span = element("span");
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
			attr(span, "slot", "buttons");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			mount_component(button0, span, null);
			append(span, t);
			mount_component(button1, span, null);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			destroy_component(button0);
			destroy_component(button1);
		}
	};
}

function create_fragment(ctx) {
	let row0;
	let t0;
	let row1;
	let t1;
	let current_block_type_index;
	let if_block;
	let t2;
	let popup;
	let updating_showPopup;
	let current;

	row0 = new Row({
			props: {
				maximize: true,
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			}
		});

	row1 = new Row({
			props: {
				maximize: true,
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	const if_block_creators = [create_if_block, create_if_block_1, create_else_block];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*selected*/ ctx[0].table !== null && /*selected*/ ctx[0].database[/*selected*/ ctx[0].table]) return 0;
		if (/*table*/ ctx[2].isNew) return 1;
		return 2;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	function popup_showPopup_binding(value) {
		/*popup_showPopup_binding*/ ctx[37](value);
	}

	let popup_props = {
		id: "askDeletePopup",
		modal: true,
		fixed: true,
		focus: "sqliteConfirmDeletionName",
		$$slots: {
			buttons: [create_buttons_slot],
			default: [create_default_slot]
		},
		$$scope: { ctx }
	};

	if (/*deleteOptions*/ ctx[3].showPopup !== void 0) {
		popup_props.showPopup = /*deleteOptions*/ ctx[3].showPopup;
	}

	popup = new Popup({ props: popup_props });
	binding_callbacks.push(() => bind(popup, 'showPopup', popup_showPopup_binding));

	return {
		c() {
			create_component(row0.$$.fragment);
			t0 = space();
			create_component(row1.$$.fragment);
			t1 = space();
			if_block.c();
			t2 = space();
			create_component(popup.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row0, target, anchor);
			insert(target, t0, anchor);
			mount_component(row1, target, anchor);
			insert(target, t1, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, t2, anchor);
			mount_component(popup, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row0_changes = {};

			if (dirty[0] & /*selected, table, sqliteConfigNodes*/ 7 | dirty[1] & /*$$scope*/ 65536) {
				row0_changes.$$scope = { dirty, ctx };
			}

			row0.$set(row0_changes);
			const row1_changes = {};

			if (dirty[0] & /*table, selected*/ 5 | dirty[1] & /*$$scope*/ 65536) {
				row1_changes.$$scope = { dirty, ctx };
			}

			row1.$set(row1_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(t2.parentNode, t2);
			}

			const popup_changes = {};

			if (dirty[0] & /*deleteOptions*/ 8 | dirty[1] & /*$$scope*/ 65536) {
				popup_changes.$$scope = { dirty, ctx };
			}

			if (!updating_showPopup && dirty[0] & /*deleteOptions*/ 8) {
				updating_showPopup = true;
				popup_changes.showPopup = /*deleteOptions*/ ctx[3].showPopup;
				add_flush_callback(() => updating_showPopup = false);
			}

			popup.$set(popup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row0.$$.fragment, local);
			transition_in(row1.$$.fragment, local);
			transition_in(if_block);
			transition_in(popup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row0.$$.fragment, local);
			transition_out(row1.$$.fragment, local);
			transition_out(if_block);
			transition_out(popup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row0, detaching);
			if (detaching) detach(t0);
			destroy_component(row1, detaching);
			if (detaching) detach(t1);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(t2);
			destroy_component(popup, detaching);
		}
	};
}

RED.nodes.registerType('sqlite-plugin-red', {
	category: 'config',
	hasUsers: false,
	defaults: {},
	onpaletteremove() {
		RED.sidebar.removeTab('sqlite-plugin-red');
	},
	onpaletteadd() {
		let init = true;

		RED.sidebar.addTab({
			id: 'sqlite-plugin-red',
			label: 'Sqlite',
			name: 'Sqlite Tab',
			content: '<div id="sqlite-plugin-red-svelte-container"></div>',
			closeable: true,
			disableOnEdit: true,
			iconClass: 'fa fa-table',
			onchange() {
				if (init) {
					render(this, { minWidth: 'auto' });
				}

				init = false;
			}
		});
	}
});

function instance($$self, $$props, $$invalidate) {
	let selected = {
		databaseId: '',
		path: '',
		table: null,
		database: []
	};

	let sqliteConfigNodes = [];
	let table = tableHelper.getDefaultTable();
	let tableBackupName = '';

	const changeDb = () => {
		dbHelper.clearDbStructure(selected);

		if (selected.databaseId) {
			$$invalidate(0, selected.path = sqliteConfigNodes.find(database => database.id === selected.databaseId).db, selected);
		}

		dbHelper.getStructure(selected).then(res => $$invalidate(0, selected = res)).catch(e => error$1.setError(e));
	};

	const changeTable = () => {
		$$invalidate(2, table = tableHelper.prepareTable(table, selected));
	};

	const addTable = () => {
		$$invalidate(2, table = tableHelper.prepareNewTable(table, true));
		$$invalidate(0, selected.table = null, selected);
		setTimeout(() => window.$('#newSqliteTable-startEdit').click(), 100);
		setTimeout(() => window.$('#newSqliteTable-addRow').click(), 100);
		setTimeout(() => window.$('#node-input-sqlite-newTablename').focus(), 100);
	};

	const abortAddTable = () => $$invalidate(2, table = tableHelper.prepareNewTable(table, false));

	const reselectTable = () => {
		const tableIndex = selected.database.findIndex(t => t.name === table.name);

		if (tableIndex >= 0) {
			$$invalidate(0, selected.table = tableIndex, selected);
			$$invalidate(2, table = tableHelper.prepareTable(table, selected));
			$$invalidate(2, table.edit = false, table);
			$$invalidate(2, table.isNew = false, table);
		} else {
			$$invalidate(0, selected.table = null, selected);
		}
	};

	const changeTablename = () => {
		$$invalidate(0, selected.path = sqliteConfigNodes.find(database => database.id === selected.databaseId).db, selected);
		const sql = 'ALTER TABLE "' + table.oldName + '" RENAME TO "' + table.name + '";';

		window.$.get('handleSqliteRequest?path=' + selected.path + '&sql=' + sql + '&command=run').success(result => {
			dbHelper.getStructure(selected).then(res => {
				$$invalidate(0, selected = res);
				$$invalidate(2, table.editTableName = !table.editTableName, table);
				reselectTable();
			});
		}).catch(e => error$1.setError(e.responseText));
	};

	const abortChangeTablename = () => {
		$$invalidate(2, table.editTableName = !table.editTableName, table);
		$$invalidate(2, table.name = table.oldName, table);
	};

	const addSqlField = row => {
		const indexes = tableHelper.getIndexes(table.header);

		// From SQLite FAQ: SQLite has limited ALTER TABLE support that you can use to add a column to the end of a table or to change the name of a table. 
		// If you want to make more complex changes in the structure of a table, you will have to recreate the table.
		const needNewTable = row[indexes.ai] || row[indexes.pk] || row[indexes.unique] || row[indexes.notnull];

		if (!needNewTable) {
			const sql = `ALTER TABLE "${tableBackupName}" ADD COLUMN "${row[indexes.name]}" ${row[indexes.type]}`;
			window.$.get('handleSqliteRequest?path=' + selected.path + '&sql=' + sql + '&command=run');
		} else {
			let fieldnames = table.rows.map(f => f[indexes.name]);

			// the "old" table does not have the new field...
			fieldnames.pop();

			fieldnames = fieldnames.join(',');

			window.$.get(`handleSqliteRequest?path=${selected.path}&fields=${fieldnames}&fieldsql=${tableHelper.createFieldsSql(table)}&backupname=${tableBackupName}&action=createTableNewProp`).fail(e => {
				table.rows.pop();
				error$1.setError(e);
			});
		}
	};

	const changeSqlField = (row, i, oldRow) => {
		let sql;
		const indexes = tableHelper.getIndexes(table.header);
		let nameChanged = row[indexes.name] !== oldRow[indexes.name];

		// if something else has changed
		const columnPropChanged = !row.every((el, i) => {
			if (i === indexes.name) {
				return true;
			} else {
				return row[i] === oldRow[i];
			}
		});

		// if only name was changed, we can use alter
		// if name column was changed, this must be called first else the function later won't find the column!
		if (nameChanged) {
			sql = `ALTER TABLE "${tableBackupName}" RENAME COLUMN "${oldRow[indexes.name]}" TO "${row[indexes.name]}";`;
			window.$.get('handleSqliteRequest?path=' + selected.path + '&sql=' + sql + '&command=run').fail(e => error$1.setError(e));
		}

		// if a prop has changed we must clone the db, change the column, insert the values and drop the old db
		// there should be NO! sqlite feature for this in the future
		if (columnPropChanged) {
			const fieldnames = table.rows.map(f => f[indexes.name]).join(',');

			window.$.get(`handleSqliteRequest?path=${selected.path}&fields=${fieldnames}&fieldsql=${tableHelper.createFieldsSql(table)}&backupname=${tableBackupName}&action=createTableNewProp`).fail(e => {
				oldRow[indexes.name] = row[indexes.name];
				$$invalidate(2, table.rows[i] = [...oldRow], table);
				error$1.setError(e);
			});
		}
	};

	let deleteOptions = {
		name: '',
		type: '',
		inputDeleteName: '',
		showPopup: false
	};

	let prepareDeletePopup = (name, type) => {
		$$invalidate(3, deleteOptions.name = name, deleteOptions);
		$$invalidate(3, deleteOptions.inputDeleteName = '', deleteOptions);
		$$invalidate(3, deleteOptions.showPopup = true, deleteOptions);
	};

	const deleteSqlField = (i, row) => {
		console.log(1, table.name, deleteOptions);
		const indexes = tableHelper.getIndexes(table.header);
		$$invalidate(3, deleteOptions.name = row[indexes.name], deleteOptions);
		const needNewTable = row[indexes.ai] || row[indexes.pk] || row[indexes.unique] || row[indexes.notnull];

		if (!needNewTable) {
			sql = 'ALTER TABLE "' + tableBackupName + '" DROP COLUMN "' + deleteOptions.name + '"';
			console.log(2, sql);

			window.$.get('handleSqliteRequest?path=' + selected.path + '&sql=' + sql + '&command=run').fail(e => {
				error$1.setError(e);
				reselectTable();
			});
		} else {
			let fieldnames = table.rows.map(f => f[indexes.name]).join(',');

			window.$.get(`handleSqliteRequest?path=${selected.path}&fields=${fieldnames}&fieldsql=${tableHelper.createFieldsSql(table)}&backupname=${tableBackupName}&action=createTableNewProp`).fail(e => {
				error$1.setError(e);
				reselectTable();
			});
		}
	};

	const deleteTable = (closeDeletePopup = false, reselect = false) => {
		if (deleteOptions.inputDeleteName !== deleteOptions.name) {
			RED.notify('Please enter the name to confirm', { type: 'error' });
			return;
		}

		if (closeDeletePopup) closePopup('askDeletePopup');

		window.$.get(`handleSqliteRequest?path=${selected.path}&sql=DROP TABLE "${deleteOptions.name}";&command=run`).success(result => {
			dbHelper.getStructure(selected).then(res => {
				$$invalidate(0, selected = res);
				const tableName = table.name;
				$$invalidate(2, table = tableHelper.getDefaultTable());
				$$invalidate(0, selected.table = null, selected);

				if (reselect) {
					$$invalidate(2, table.name = tableName, table);
					reselectTable();
				}
			});
		}).fail(e => {
			error$1.setError(e);
			reselectTable();
		});
	};

	const prepareNewRow = (r, i) => {
		r[0] = i;
		r[2] = 'TEXT';
	};

	const copyTable = () => {
		tableBackupName = table.name + '__sqlite_tab_copy__';

		if (selected.database.find(t => t.name === tableBackupName)) {
			const e = 'This database has already a backup (' + tableBackupName + ') for the selected table. This happend because changing the table was not ended correctly last time. Please check which is the correct version and delete the other manually!';
			error$1.setError(e);
			$$invalidate(2, table = tableHelper.getDefaultTable());
			$$invalidate(0, selected.table = null, selected);
		} else {
			$$invalidate(2, table.edit = true, table);
			const indexes = tableHelper.getIndexes(table.header);
			const fieldnames = table.rows.map(f => f[indexes.name]).join(',');
			window.$.get(`handleSqliteRequest?path=${selected.path}&fields=${fieldnames}&fieldsql=${tableHelper.createFieldsSql(table)}&tablename=${table.name}&backupname=${tableBackupName}&action=createCopy`);
		}
	};

	const createTable = () => {
		window.$.get('handleSqliteRequest?path=' + selected.path + '&sql=' + tableHelper.createTableSql(selected.path, table) + '&command=run').success(result => {
			dbHelper.getStructure(selected).then(res => {
				$$invalidate(0, selected = res);
				reselectTable();
			});
		}).fail(e => {
			error$1.setError(e);
			$$invalidate(0, selected.table = null, selected);
		});
	};

	const commitChanges = () => {
		window.$.get(`handleSqliteRequest?path=${selected.path}&tablename=${table.name}&backupname=${tableBackupName}&action=commit`).fail(e => {
			error$1.setError(e);
		}).always(() => {
			dbHelper.getStructure(selected).then(res => {
				$$invalidate(0, selected = res);
				reselectTable();
				tableBackupName = '';
			});
		});
	};

	const cancelChanges = () => {
		$$invalidate(3, deleteOptions.name = tableBackupName, deleteOptions);
		$$invalidate(3, deleteOptions.type = 'table', deleteOptions);
		$$invalidate(3, deleteOptions.inputDeleteName = tableBackupName, deleteOptions);
		deleteTable(false, true);
	};

	sqliteConfigNodes = sqliteConfig.getNodes(sqliteConfigNodes);

	onMount(() => {
		const hookOnSqliteEvents = event => {
			RED.events.on('nodes:' + event, e => {
				if (e.type === 'sqlitedb') {
					$$invalidate(1, sqliteConfigNodes = sqliteConfig.getNodes(sqliteConfigNodes));
					$$invalidate(0, selected.databaseId = e.id, selected);
				}
			});
		};

		hookOnSqliteEvents('add');
		hookOnSqliteEvents('change');
		hookOnSqliteEvents('remove');
	});

	function select_value_binding(value) {
		if ($$self.$$.not_equal(selected.databaseId, value)) {
			selected.databaseId = value;
			$$invalidate(0, selected);
		}
	}

	const click_handler = () => sqliteConfig.add(sqliteConfigNodes);
	const click_handler_1 = () => sqliteConfig.edit(sqliteConfigNodes, selected);

	function input_value_binding(value) {
		if ($$self.$$.not_equal(table.name, value)) {
			table.name = value;
			$$invalidate(2, table);
		}
	}

	function select_value_binding_1(value) {
		if ($$self.$$.not_equal(selected.table, value)) {
			selected.table = value;
			$$invalidate(0, selected);
		}
	}

	const click_handler_2 = () => $$invalidate(2, table = tableHelper.prepareEditTableName(table, selected));
	const click_handler_3 = () => prepareDeletePopup(selected.database[selected.table].name, 'table');
	const func = row => addSqlField(row);
	const func_1 = (row, i, old) => changeSqlField(row, i, old);
	const func_2 = (t, i, row) => deleteSqlField(i, row);

	function table_1_rows_binding(value) {
		if ($$self.$$.not_equal(table.rows, value)) {
			table.rows = value;
			$$invalidate(2, table);
		}
	}

	function input_value_binding_1(value) {
		if ($$self.$$.not_equal(table.name, value)) {
			table.name = value;
			$$invalidate(2, table);
		}
	}

	const change_handler = () => $$invalidate(2, table = tableHelper.checkTableAndFieldName(selected, table));

	function table_1_value_binding(value) {
		table = value;
		$$invalidate(2, table);
	}

	const click_handler_4 = () => closePopup('askDeletePopup');
	const click_handler_5 = () => deleteTable(true);

	function input_value_binding_2(value) {
		if ($$self.$$.not_equal(deleteOptions.inputDeleteName, value)) {
			deleteOptions.inputDeleteName = value;
			$$invalidate(3, deleteOptions);
		}
	}

	function popup_showPopup_binding(value) {
		if ($$self.$$.not_equal(deleteOptions.showPopup, value)) {
			deleteOptions.showPopup = value;
			$$invalidate(3, deleteOptions);
		}
	}

	return [
		selected,
		sqliteConfigNodes,
		table,
		deleteOptions,
		changeDb,
		changeTable,
		addTable,
		abortAddTable,
		changeTablename,
		abortChangeTablename,
		addSqlField,
		changeSqlField,
		prepareDeletePopup,
		deleteSqlField,
		deleteTable,
		prepareNewRow,
		copyTable,
		createTable,
		commitChanges,
		cancelChanges,
		select_value_binding,
		click_handler,
		click_handler_1,
		input_value_binding,
		select_value_binding_1,
		click_handler_2,
		click_handler_3,
		func,
		func_1,
		func_2,
		table_1_rows_binding,
		input_value_binding_1,
		change_handler,
		table_1_value_binding,
		click_handler_4,
		click_handler_5,
		input_value_binding_2,
		popup_showPopup_binding
	];
}

class Sqlite_plugin_red extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {}, add_css, [-1, -1]);
	}
}



              }
            </script>
            <script type="text/x-red" data-template-name="sqlite-plugin-red">
              <div id='sqlite-plugin-red-svelte-container'></div>
            </script>
            <script type="text/x-red" data-help-name="sqlite-plugin-red">
                No documentation yet.
            </script>
        