<script context='module'>
  RED.nodes.registerType('sqlite-plugin-red', {
    category: 'config',
    hasUsers: false,
    defaults: {},
    onpaletteremove: function () {
      RED.sidebar.removeTab('sqlite-plugin-red')
    },
    onpaletteadd: function () {     
      let init = true
      RED.sidebar.addTab({
        id: 'sqlite-plugin-red',
        label: 'Sqlite',
        name: 'Sqlite Tab',
        content: '<div id="sqlite-plugin-red-svelte-container"></div>',
        closeable: true,
        disableOnEdit: true,
        iconClass: 'fa fa-table',
        onchange: function () {
          if (init) {
            render(this, { minWidth: 'auto' })
          }
          init = false
        },
      })
    }
  })
</script>

<script>
  import { Row, Input, Button, Select, Table, Callout } from 'svelte-integration-red/components'
  import Popup, { closePopup } from 'svelte-integration-red/components/Popup.svelte'
  import tableHelper from './utils/tableHelper.js'
  import sqliteConfig from './utils/sqliteConfig.js'
  import { setError } from './utils/error.js'
  import dbHelper from './utils/dbHelper.js'
  import { onMount } from 'svelte'

  let selected = {
    databaseId: '',
    path: '',
    table: null,
    database: []
  }
  let sqliteConfigNodes = []
  let table = tableHelper.getDefaultTable()
  let tableBackupName = ''
  const backupSuffix = '__sqlite_tab_copy__'

  const changeDb = () => {
    dbHelper.clearDbStructure(selected)
    if (selected.databaseId) {
      selected.path = sqliteConfigNodes.find(database => database.id === selected.databaseId).db
    }
    dbHelper.getStructure(selected)
      .then( res => selected = res)
      .catch(e => setError(e))
  }

  const changeTable = () => {
    table = tableHelper.prepareTable(table, selected)
  }

  const addTable = () => {
    table = tableHelper.prepareNewTable(table, true)
    selected.table = null
    setTimeout(() => window.$('#newSqliteTable-startEdit').click(), 100)
    setTimeout(() => window.$('#newSqliteTable-addRow').click(), 100)
    setTimeout(() => window.$('#node-input-sqlite-newTablename').focus(), 100)
  }

  const abortAddTable = () => table = tableHelper.prepareNewTable(table, false)

  const reselectTable = () => {
    const tableIndex = selected.database.findIndex(t => t.name === table.name)
    if (tableIndex >= 0) {
      selected.table = tableIndex 
      table = tableHelper.prepareTable(table, selected)
      table.edit = false
      table.isNew = false
    } else {
      selected.table = null
    }
  }

  const changeTablename = () => {
    selected.path = sqliteConfigNodes.find(database => database.id === selected.databaseId).db
    const sql = 'ALTER TABLE "' + table.oldName + '" RENAME TO "' + table.name + '";'
    window.$.get('handleSqliteRequest?path=' + selected.path + '&sql=' + sql + '&command=run')
    .success((result) => {
      dbHelper.getStructure(selected).then( (res) => {
        selected = res
        table.editTableName = !table.editTableName
        reselectTable()
      })
    })
    .catch((e) => setError(e.responseText))
  }
  const abortChangeTablename = () => {
    table.editTableName = !table.editTableName
    table.name = table.oldName
  }

  const addSqlField = (row) => {
    const indexes = tableHelper.getIndexes(table.header)  
      // From SQLite FAQ: SQLite has limited ALTER TABLE support that you can use to add a column to the end of a table or to change the name of a table. 
    // If you want to make more complex changes in the structure of a table, you will have to recreate the table.
    const needNewTable = (row[indexes.ai] || row[indexes.pk] || row[indexes.unique] || row[indexes.notnull])
    if (!needNewTable) {
      const sql = `ALTER TABLE "${tableBackupName}" ADD COLUMN "${row[indexes.name]}" ${row[indexes.type]}`
      window.$.get('handleSqliteRequest?path=' + selected.path + '&sql=' + sql + '&command=run')
    } else {
      let fieldnames = table.rows.map(f => f[indexes.name])
      // the "old" table does not have the new field...
      fieldnames.pop()
      fieldnames = fieldnames.join(',')
      window.$.get(`handleSqliteRequest?path=${selected.path}&fields=${fieldnames}&fieldsql=${tableHelper.createFieldsSql(table)}&backupname=${tableBackupName}&action=createTableNewProp`)
        .fail(e => {
          table.rows.pop()
          setError(e)
        })
    }
  }

  const changeSqlField = (row, i, oldRow) => {
    let sql
    const indexes = tableHelper.getIndexes(table.header)
    let nameChanged = row[indexes.name] !== oldRow[indexes.name]
    // if something else has changed
    const columnPropChanged = !row.every( (el, i) => {
      if (i === indexes.name) {
        return true
      } else {
        return row[i] === oldRow[i]
      }
    })
    // if only name was changed, we can use alter
    // if name column was changed, this must be called first else the function later won't find the column!
    if (nameChanged) {
      sql = `ALTER TABLE "${tableBackupName}" RENAME COLUMN "${oldRow[indexes.name]}" TO "${row[indexes.name]}";`
      window.$.get('handleSqliteRequest?path=' + selected.path + '&sql=' + sql + '&command=run')
        .fail(e => setError(e))
    }
    // if a prop has changed we must clone the db, change the column, insert the values and drop the old db
    // there should be NO! sqlite feature for this in the future
    if (columnPropChanged) {
      const fieldnames = table.rows.map(f => f[indexes.name]).join(',')
      window.$.get(`handleSqliteRequest?path=${selected.path}&fields=${fieldnames}&fieldsql=${tableHelper.createFieldsSql(table)}&backupname=${tableBackupName}&action=createTableNewProp`)
        .fail(e => {
          oldRow[indexes.name] = row[indexes.name]
          table.rows[i] = [...oldRow]
          setError(e)
        })
    }
  }
  
  let deleteOptions = {
    name: '',
    type: '',
    inputDeleteName: '',
    showPopup: false
  }
  let prepareDeletePopup = (name, type) => {
    deleteOptions.name = name
    deleteOptions.inputDeleteName = ''
    deleteOptions.showPopup = true
  }

  const deleteSqlField = (i, row) => {
    console.log(1, table.name, deleteOptions)
    const indexes = tableHelper.getIndexes(table.header)
    deleteOptions.name = row[indexes.name]
    const needNewTable = (row[indexes.ai] || row[indexes.pk] || row[indexes.unique] || row[indexes.notnull])
    if (!needNewTable) {
      sql = 'ALTER TABLE "' + tableBackupName + '" DROP COLUMN "' + deleteOptions.name + '"'
      console.log(2, sql)
      window.$.get('handleSqliteRequest?path=' + selected.path + '&sql=' + sql + '&command=run')
        .fail((e) => {
          setError(e)
          reselectTable()
        })
    } else {
      let fieldnames = table.rows.map(f => f[indexes.name]).join(',')
      window.$.get(`handleSqliteRequest?path=${selected.path}&fields=${fieldnames}&fieldsql=${tableHelper.createFieldsSql(table)}&backupname=${tableBackupName}&action=createTableNewProp`)
        .fail(e => {
          setError(e)
          reselectTable()
        })
    }
  }

  const deleteTable = (closeDeletePopup=false, reselect=false) => {
    if (deleteOptions.inputDeleteName !== deleteOptions.name) {
      RED.notify( 'Please enter the name to confirm', { type: 'error'})
      return
    }
    if (closeDeletePopup) closePopup('askDeletePopup')
    window.$.get(`handleSqliteRequest?path=${selected.path}&sql=DROP TABLE "${deleteOptions.name}";&command=run`)
      .success((result) =>  {
        dbHelper.getStructure(selected).then( (res) => {
          selected = res
          const tableName = table.name
          table = tableHelper.getDefaultTable()
          selected.table = null
          if (reselect) {
            table.name = tableName
            reselectTable()
          }
        })
      })
      .fail((e) => {
        setError(e)
        reselectTable()
      })
  }

  const prepareNewRow = (r, i) => {
    r[0] = i
    r[2] = 'TEXT'
  }

  const copyTable = () => {
    tableBackupName = table.name + '__sqlite_tab_copy__'
    if (selected.database.find(t => t.name === tableBackupName)) {
      const e = 'This database has already a backup (' + tableBackupName + ') for the selected table. This happend because changing the table was not ended correctly last time. Please check which is the correct version and delete the other manually!'
      setError(e)
      table = tableHelper.getDefaultTable()
      selected.table = null
    } else {
      table.edit = true
      const indexes = tableHelper.getIndexes(table.header)
      const fieldnames = table.rows.map(f => f[indexes.name]).join(',')
      window.$.get(`handleSqliteRequest?path=${selected.path}&fields=${fieldnames}&fieldsql=${tableHelper.createFieldsSql(table)}&tablename=${table.name}&backupname=${tableBackupName}&action=createCopy`)
    }
  
  }

  const createTable = () => {
    window.$.get('handleSqliteRequest?path=' + selected.path + '&sql=' + tableHelper.createTableSql(selected.path, table) + '&command=run')
    .success((result) => {
      dbHelper.getStructure(selected)
        .then( (res) => {
          selected = res
          reselectTable()
        })
    }).fail((e) => {
      setError(e)
      selected.table = null
    })
  }
  
  const commitChanges = () => {
    window.$.get(`handleSqliteRequest?path=${selected.path}&tablename=${table.name}&backupname=${tableBackupName}&action=commit`)
      .fail((e) => {
        setError(e)
      })
      .always( () => {
        dbHelper.getStructure(selected).then( res => {
          selected = res
          reselectTable()
          tableBackupName = ''
        })
      })
  }

  const cancelChanges = () => {
    deleteOptions.name = tableBackupName
    deleteOptions.type = 'table'
    deleteOptions.inputDeleteName = tableBackupName
    deleteTable(false, true)
  }

  sqliteConfigNodes = sqliteConfig.getNodes(sqliteConfigNodes)
  onMount(() => {
    const hookOnSqliteEvents = (event) => {
      RED.events.on('nodes:' + event, (e) => {
        if (e.type === 'sqlitedb') {
          sqliteConfigNodes = sqliteConfig.getNodes(sqliteConfigNodes)
          selected.databaseId = e.id
        }
      })
    }
    hookOnSqliteEvents('add')
    hookOnSqliteEvents('change')
    hookOnSqliteEvents('remove')
  })
</script>

<!-- DB selection -->
<Row maximize>
  <Select bind:value={selected.databaseId} on:change={changeDb} inline disabled={table.edit}>
    <option value=''>-- Select a database --</option>
    <!-- Use unique config node id instead of array index as we may change the config nodes (add, delete,...) -->
    {#each sqliteConfigNodes as {id, db} }
      <option value={id}>{db}</option>
    {/each}
  </Select>
  <Button on:click={() => sqliteConfig.add(sqliteConfigNodes)} icon="plus" disabled={table.edit} />
  <Button on:click={() => sqliteConfig.edit(sqliteConfigNodes, selected)} icon="edit" disabled={!selected.databaseId || table.edit} />
</Row>

<!-- Table selection -->
<Row maximize>
  {#if table.editTableName}
    <Input id="sqlite-newTablename" bind:value={table.name} placeholder='New tablename' maximize inline/>
    <Button icon="check" label="Change name" on:click={changeTablename}  disabled={table.name === table.oldName} />
    <Button icon="close" label="Cancel" on:click={abortChangeTablename} />
  {:else}
    <Select bind:value={selected.table} disabled={!selected.databaseId || table.edit} on:change={changeTable} inline>
      <option value={null}>-- Select a table --</option>
      {#each selected.database as {name}, i}
        <option value={i}>{name}</option>
      {/each}
    </Select>

    {#if table.isNew}
      <Button icon="close" on:click={abortAddTable} />
    {:else}
      <Button icon="plus" on:click={addTable} disabled={!selected.databaseId || table.edit} />
    {/if}
    <Button icon="edit" on:click={() => table = tableHelper.prepareEditTableName(table, selected)}  disabled={selected.table === null || table.edit} />
    <Button on:click={() => prepareDeletePopup(selected.database[selected.table].name, 'table')} icon="trash" disabled={selected.table === null || table.edit} />
  {/if}  
</Row>

<!-- Show SQL Fields / Create new Table -->
{#if selected.table !== null && selected.database[selected.table]}
  <Callout type="warning" closeable>
    <span slot="header">Warning</span>
    Always backup your database before editing!
  </Callout>
  <Table id="selectedSqliteTable" header={table.header} bind:rows={table.rows} maximize editable editColumns={false} 
    beforeEditTable={copyTable} afterEditTable={commitChanges} afterCancelEditTable={cancelChanges}
    beforeAddRow={prepareNewRow} afterAddRow={(row) => addSqlField(row)} afterEditRow={(row, i, old) => changeSqlField(row, i, old)}
    afterDelete={(t, i, row) => deleteSqlField(i, row)}>
  </Table>
{:else if table.isNew} 
  <Input id="sqlite-newTablename" bind:value={table.name} placeholder='New tablename' on:change={() => table = tableHelper.checkTableAndFieldName(selected, table)}/>
  <Table id="newSqliteTable" bind:value={table} maximize editable editColumns={false} 
    afterEditTable={createTable}
    beforeAddRow={prepareNewRow}
    afterCancelEditTable={abortAddTable}>
  </Table>
  {:else}
    <div class="text">
      No database / table selected.
    </div>
{/if}

<Popup id="askDeletePopup" modal fixed bind:showPopup={deleteOptions.showPopup} focus="sqliteConfirmDeletionName">
  <h2>Warning: Deleting is irreversible!</h2>
  <Input bind:value={deleteOptions.inputDeleteName} id="sqliteConfirmDeletionName" />
  <p>To confirm enter the {deleteOptions.type} name: {deleteOptions.name} </p>
  <span slot="buttons">
    <Button label="Cancel" on:click={() => closePopup('askDeletePopup')} />
    <Button label="Delete" primary on:click={() => deleteTable(true)} />
  </span>
</Popup>

<style>
  :global(#sqlite-plugin-red-svelte-container) { padding: 20px; }
</style>
